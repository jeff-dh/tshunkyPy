Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    INTEGER_DIVIDE

Grammar

Rule 0     S' -> block
Rule 1     block -> chunk
Rule 2     chunk -> chunk2 laststat
Rule 3     chunk -> chunk2
Rule 4     chunk -> laststat
Rule 5     chunk2 -> stat optsemi
Rule 6     chunk2 -> chunk stat optsemi
Rule 7     optsemi -> ;
Rule 8     optsemi -> empty
Rule 9     laststat -> RETURN explist optsemi
Rule 10    laststat -> RETURN optsemi
Rule 11    laststat -> BREAK optsemi
Rule 12    stat -> varlist = explist
Rule 13    stat -> LOCAL namelist = explist
Rule 14    stat -> LOCAL namelist
Rule 15    stat -> FUNCTION funcname funcbody
Rule 16    stat -> LOCAL FUNCTION name funcbody
Rule 17    stat -> functioncall
Rule 18    stat -> DO block END
Rule 19    stat -> WHILE exp DO block END
Rule 20    stat -> REPEAT block UNTIL exp
Rule 21    stat -> if elseiflist else END
Rule 22    stat -> FOR name = exp , exp DO block END
Rule 23    stat -> FOR name = exp , exp , exp DO block END
Rule 24    stat -> FOR namelist IN explist DO block END
Rule 25    if -> IF exp THEN block
Rule 26    elseiflist -> elseif
Rule 27    elseiflist -> elseiflist elseif
Rule 28    elseiflist -> empty
Rule 29    elseif -> ELSEIF exp THEN block
Rule 30    else -> ELSE block
Rule 31    else -> empty
Rule 32    var -> name
Rule 33    var -> prefixexp [ exp ]
Rule 34    var -> prefixexp . name
Rule 35    varlist -> var
Rule 36    varlist -> varlist , var
Rule 37    name -> IDENTIFIER
Rule 38    funcname -> funcname2
Rule 39    funcname -> funcname2 : name
Rule 40    funcname2 -> name
Rule 41    funcname2 -> funcname2 . name
Rule 42    namelist -> name
Rule 43    namelist -> namelist , name
Rule 44    exp -> NIL
Rule 45    exp -> FALSE
Rule 46    exp -> TRUE
Rule 47    exp -> NUMBER
Rule 48    exp -> string
Rule 49    exp -> TDOT
Rule 50    exp -> function
Rule 51    exp -> prefixexp
Rule 52    exp -> tableconstructor
Rule 53    exp -> op
Rule 54    explist -> exp
Rule 55    explist -> explist , exp
Rule 56    prefixexp -> var
Rule 57    prefixexp -> functioncall
Rule 58    prefixexp -> ( exp )
Rule 59    function -> FUNCTION funcbody
Rule 60    functioncall -> prefixexp args
Rule 61    functioncall -> prefixexp : name args
Rule 62    end -> END
Rule 63    funcbody -> ( parlist ) block END
Rule 64    funcbody -> ( ) block END
Rule 65    parlist -> namelist
Rule 66    parlist -> namelist , TDOT
Rule 67    parlist -> TDOT
Rule 68    args -> ( )
Rule 69    args -> ( explist )
Rule 70    args -> tableconstructor
Rule 71    args -> string
Rule 72    tableconstructor -> { fieldlist }
Rule 73    tableconstructor -> { }
Rule 74    field -> [ exp ] = exp
Rule 75    field -> name = exp
Rule 76    field -> exp
Rule 77    fieldlist -> fieldlist2 optfieldsep
Rule 78    fieldlist2 -> field
Rule 79    fieldlist2 -> fieldlist2 fieldsep field
Rule 80    optfieldsep -> fieldsep
Rule 81    optfieldsep -> empty
Rule 82    fieldsep -> ,
Rule 83    fieldsep -> ;
Rule 84    string -> STRING
Rule 85    op -> op_1
Rule 86    op_1 -> op_1 OR op_2
Rule 87    op_1 -> op_2
Rule 88    op_2 -> op_2 AND op_3
Rule 89    op_2 -> op_3
Rule 90    op_3 -> op_3 LT op_4
Rule 91    op_3 -> op_3 LTE op_4
Rule 92    op_3 -> op_3 GT op_4
Rule 93    op_3 -> op_3 GTE op_4
Rule 94    op_3 -> op_3 NE op_4
Rule 95    op_3 -> op_3 EQUALS op_4
Rule 96    op_3 -> op_4
Rule 97    op_4 -> op_4 CONCAT op_5
Rule 98    op_4 -> op_5
Rule 99    op_5 -> op_5 PLUS op_6
Rule 100   op_5 -> op_5 MINUS op_6
Rule 101   op_5 -> op_6
Rule 102   op_6 -> op_6 TIMES op_7
Rule 103   op_6 -> op_6 DIVIDE op_7
Rule 104   op_6 -> op_6 % op_7
Rule 105   op_6 -> op_7
Rule 106   op_7 -> NOT op_8
Rule 107   op_7 -> HASH op_8
Rule 108   op_7 -> MINUS op_8
Rule 109   op_7 -> op_8
Rule 110   op_8 -> op_8 CIRCUMFLEX op_9
Rule 111   op_8 -> op_9
Rule 112   op_9 -> exp
Rule 113   empty -> <empty>

Terminals, with rules where they appear

%                    : 104
(                    : 58 63 64 68 69
)                    : 58 63 64 68 69
,                    : 22 23 23 36 43 55 66 82
.                    : 34 41
:                    : 39 61
;                    : 7 83
=                    : 12 13 22 23 74 75
AND                  : 88
BREAK                : 11
CIRCUMFLEX           : 110
CONCAT               : 97
DIVIDE               : 103
DO                   : 18 19 22 23 24
ELSE                 : 30
ELSEIF               : 29
END                  : 18 19 21 22 23 24 62 63 64
EQUALS               : 95
FALSE                : 45
FOR                  : 22 23 24
FUNCTION             : 15 16 59
GT                   : 92
GTE                  : 93
HASH                 : 107
IDENTIFIER           : 37
IF                   : 25
IN                   : 24
INTEGER_DIVIDE       : 
LOCAL                : 13 14 16
LT                   : 90
LTE                  : 91
MINUS                : 100 108
NE                   : 94
NIL                  : 44
NOT                  : 106
NUMBER               : 47
OR                   : 86
PLUS                 : 99
REPEAT               : 20
RETURN               : 9 10
STRING               : 84
TDOT                 : 49 66 67
THEN                 : 25 29
TIMES                : 102
TRUE                 : 46
UNTIL                : 20
WHILE                : 19
[                    : 33 74
]                    : 33 74
error                : 
{                    : 72 73
}                    : 72 73

Nonterminals, with rules where they appear

args                 : 60 61
block                : 18 19 20 22 23 24 25 29 30 63 64 0
chunk                : 1 6
chunk2               : 2 3
else                 : 21
elseif               : 26 27
elseiflist           : 21 27
empty                : 8 28 31 81
end                  : 
exp                  : 19 20 22 22 23 23 23 25 29 33 54 55 58 74 74 75 76 112
explist              : 9 12 13 24 55 69
field                : 78 79
fieldlist            : 72
fieldlist2           : 77 79
fieldsep             : 79 80
funcbody             : 15 16 59
funcname             : 15
funcname2            : 38 39 41
function             : 50
functioncall         : 17 57
if                   : 21
laststat             : 2 4
name                 : 16 22 23 32 34 39 40 41 42 43 61 75
namelist             : 13 14 24 43 65 66
op                   : 53
op_1                 : 85 86
op_2                 : 86 87 88
op_3                 : 88 89 90 91 92 93 94 95
op_4                 : 90 91 92 93 94 95 96 97
op_5                 : 97 98 99 100
op_6                 : 99 100 101 102 103 104
op_7                 : 102 103 104 105
op_8                 : 106 107 108 109 110
op_9                 : 110 111
optfieldsep          : 77
optsemi              : 5 6 9 10 11
parlist              : 63
prefixexp            : 33 34 51 60 61
stat                 : 5 6
string               : 48 71
tableconstructor     : 52 70
var                  : 35 36 56
varlist              : 12 36

Parsing method: LALR

state 0

    (0) S' -> . block
    (1) block -> . chunk
    (2) chunk -> . chunk2 laststat
    (3) chunk -> . chunk2
    (4) chunk -> . laststat
    (5) chunk2 -> . stat optsemi
    (6) chunk2 -> . chunk stat optsemi
    (9) laststat -> . RETURN explist optsemi
    (10) laststat -> . RETURN optsemi
    (11) laststat -> . BREAK optsemi
    (12) stat -> . varlist = explist
    (13) stat -> . LOCAL namelist = explist
    (14) stat -> . LOCAL namelist
    (15) stat -> . FUNCTION funcname funcbody
    (16) stat -> . LOCAL FUNCTION name funcbody
    (17) stat -> . functioncall
    (18) stat -> . DO block END
    (19) stat -> . WHILE exp DO block END
    (20) stat -> . REPEAT block UNTIL exp
    (21) stat -> . if elseiflist else END
    (22) stat -> . FOR name = exp , exp DO block END
    (23) stat -> . FOR name = exp , exp , exp DO block END
    (24) stat -> . FOR namelist IN explist DO block END
    (35) varlist -> . var
    (36) varlist -> . varlist , var
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (25) if -> . IF exp THEN block
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (37) name -> . IDENTIFIER

    RETURN          shift and go to state 6
    BREAK           shift and go to state 7
    LOCAL           shift and go to state 9
    FUNCTION        shift and go to state 10
    DO              shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    FOR             shift and go to state 17
    IF              shift and go to state 20
    (               shift and go to state 21
    IDENTIFIER      shift and go to state 22

    block                          shift and go to state 1
    chunk                          shift and go to state 2
    chunk2                         shift and go to state 3
    laststat                       shift and go to state 4
    stat                           shift and go to state 5
    varlist                        shift and go to state 8
    name                           shift and go to state 11
    functioncall                   shift and go to state 12
    if                             shift and go to state 16
    var                            shift and go to state 18
    prefixexp                      shift and go to state 19

state 1

    (0) S' -> block .



state 2

    (1) block -> chunk .
    (6) chunk2 -> chunk . stat optsemi
    (12) stat -> . varlist = explist
    (13) stat -> . LOCAL namelist = explist
    (14) stat -> . LOCAL namelist
    (15) stat -> . FUNCTION funcname funcbody
    (16) stat -> . LOCAL FUNCTION name funcbody
    (17) stat -> . functioncall
    (18) stat -> . DO block END
    (19) stat -> . WHILE exp DO block END
    (20) stat -> . REPEAT block UNTIL exp
    (21) stat -> . if elseiflist else END
    (22) stat -> . FOR name = exp , exp DO block END
    (23) stat -> . FOR name = exp , exp , exp DO block END
    (24) stat -> . FOR namelist IN explist DO block END
    (35) varlist -> . var
    (36) varlist -> . varlist , var
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (25) if -> . IF exp THEN block
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (37) name -> . IDENTIFIER

    $end            reduce using rule 1 (block -> chunk .)
    END             reduce using rule 1 (block -> chunk .)
    UNTIL           reduce using rule 1 (block -> chunk .)
    ELSEIF          reduce using rule 1 (block -> chunk .)
    ELSE            reduce using rule 1 (block -> chunk .)
    LOCAL           shift and go to state 9
    FUNCTION        shift and go to state 10
    DO              shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    FOR             shift and go to state 17
    IF              shift and go to state 20
    (               shift and go to state 21
    IDENTIFIER      shift and go to state 22

    stat                           shift and go to state 23
    varlist                        shift and go to state 8
    name                           shift and go to state 11
    functioncall                   shift and go to state 12
    if                             shift and go to state 16
    var                            shift and go to state 18
    prefixexp                      shift and go to state 19

state 3

    (2) chunk -> chunk2 . laststat
    (3) chunk -> chunk2 .
    (9) laststat -> . RETURN explist optsemi
    (10) laststat -> . RETURN optsemi
    (11) laststat -> . BREAK optsemi

    LOCAL           reduce using rule 3 (chunk -> chunk2 .)
    FUNCTION        reduce using rule 3 (chunk -> chunk2 .)
    DO              reduce using rule 3 (chunk -> chunk2 .)
    WHILE           reduce using rule 3 (chunk -> chunk2 .)
    REPEAT          reduce using rule 3 (chunk -> chunk2 .)
    FOR             reduce using rule 3 (chunk -> chunk2 .)
    IF              reduce using rule 3 (chunk -> chunk2 .)
    (               reduce using rule 3 (chunk -> chunk2 .)
    IDENTIFIER      reduce using rule 3 (chunk -> chunk2 .)
    $end            reduce using rule 3 (chunk -> chunk2 .)
    END             reduce using rule 3 (chunk -> chunk2 .)
    UNTIL           reduce using rule 3 (chunk -> chunk2 .)
    ELSEIF          reduce using rule 3 (chunk -> chunk2 .)
    ELSE            reduce using rule 3 (chunk -> chunk2 .)
    RETURN          shift and go to state 6
    BREAK           shift and go to state 7

    laststat                       shift and go to state 24

state 4

    (4) chunk -> laststat .

    LOCAL           reduce using rule 4 (chunk -> laststat .)
    FUNCTION        reduce using rule 4 (chunk -> laststat .)
    DO              reduce using rule 4 (chunk -> laststat .)
    WHILE           reduce using rule 4 (chunk -> laststat .)
    REPEAT          reduce using rule 4 (chunk -> laststat .)
    FOR             reduce using rule 4 (chunk -> laststat .)
    IF              reduce using rule 4 (chunk -> laststat .)
    (               reduce using rule 4 (chunk -> laststat .)
    IDENTIFIER      reduce using rule 4 (chunk -> laststat .)
    $end            reduce using rule 4 (chunk -> laststat .)
    END             reduce using rule 4 (chunk -> laststat .)
    UNTIL           reduce using rule 4 (chunk -> laststat .)
    ELSEIF          reduce using rule 4 (chunk -> laststat .)
    ELSE            reduce using rule 4 (chunk -> laststat .)


state 5

    (5) chunk2 -> stat . optsemi
    (7) optsemi -> . ;
    (8) optsemi -> . empty
    (113) empty -> .

    ;               shift and go to state 26
    RETURN          reduce using rule 113 (empty -> .)
    BREAK           reduce using rule 113 (empty -> .)
    LOCAL           reduce using rule 113 (empty -> .)
    FUNCTION        reduce using rule 113 (empty -> .)
    DO              reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    REPEAT          reduce using rule 113 (empty -> .)
    FOR             reduce using rule 113 (empty -> .)
    IF              reduce using rule 113 (empty -> .)
    (               reduce using rule 113 (empty -> .)
    IDENTIFIER      reduce using rule 113 (empty -> .)
    $end            reduce using rule 113 (empty -> .)
    END             reduce using rule 113 (empty -> .)
    UNTIL           reduce using rule 113 (empty -> .)
    ELSEIF          reduce using rule 113 (empty -> .)
    ELSE            reduce using rule 113 (empty -> .)

    optsemi                        shift and go to state 25
    empty                          shift and go to state 27

state 6

    (9) laststat -> RETURN . explist optsemi
    (10) laststat -> RETURN . optsemi
    (54) explist -> . exp
    (55) explist -> . explist , exp
    (7) optsemi -> . ;
    (8) optsemi -> . empty
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (113) empty -> .
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
    ;               shift and go to state 26
    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    LOCAL           reduce using rule 113 (empty -> .)
    DO              reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    REPEAT          reduce using rule 113 (empty -> .)
    FOR             reduce using rule 113 (empty -> .)
    IF              reduce using rule 113 (empty -> .)
    $end            reduce using rule 113 (empty -> .)
    END             reduce using rule 113 (empty -> .)
    UNTIL           reduce using rule 113 (empty -> .)
    ELSEIF          reduce using rule 113 (empty -> .)
    ELSE            reduce using rule 113 (empty -> .)
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

  ! FUNCTION        [ reduce using rule 113 (empty -> .) ]
  ! (               [ reduce using rule 113 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 113 (empty -> .) ]

    explist                        shift and go to state 28
    optsemi                        shift and go to state 29
    exp                            shift and go to state 30
    empty                          shift and go to state 27
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57

state 7

    (11) laststat -> BREAK . optsemi
    (7) optsemi -> . ;
    (8) optsemi -> . empty
    (113) empty -> .

    ;               shift and go to state 26
    LOCAL           reduce using rule 113 (empty -> .)
    FUNCTION        reduce using rule 113 (empty -> .)
    DO              reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    REPEAT          reduce using rule 113 (empty -> .)
    FOR             reduce using rule 113 (empty -> .)
    IF              reduce using rule 113 (empty -> .)
    (               reduce using rule 113 (empty -> .)
    IDENTIFIER      reduce using rule 113 (empty -> .)
    $end            reduce using rule 113 (empty -> .)
    END             reduce using rule 113 (empty -> .)
    UNTIL           reduce using rule 113 (empty -> .)
    ELSEIF          reduce using rule 113 (empty -> .)
    ELSE            reduce using rule 113 (empty -> .)

    optsemi                        shift and go to state 58
    empty                          shift and go to state 27

state 8

    (12) stat -> varlist . = explist
    (36) varlist -> varlist . , var

    =               shift and go to state 59
    ,               shift and go to state 60


state 9

    (13) stat -> LOCAL . namelist = explist
    (14) stat -> LOCAL . namelist
    (16) stat -> LOCAL . FUNCTION name funcbody
    (42) namelist -> . name
    (43) namelist -> . namelist , name
    (37) name -> . IDENTIFIER

    FUNCTION        shift and go to state 62
    IDENTIFIER      shift and go to state 22

    namelist                       shift and go to state 61
    name                           shift and go to state 63

state 10

    (15) stat -> FUNCTION . funcname funcbody
    (38) funcname -> . funcname2
    (39) funcname -> . funcname2 : name
    (40) funcname2 -> . name
    (41) funcname2 -> . funcname2 . name
    (37) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 22

    funcname                       shift and go to state 64
    funcname2                      shift and go to state 65
    name                           shift and go to state 66

state 11

    (32) var -> name .

    =               reduce using rule 32 (var -> name .)
    ,               reduce using rule 32 (var -> name .)
    :               reduce using rule 32 (var -> name .)
    [               reduce using rule 32 (var -> name .)
    .               reduce using rule 32 (var -> name .)
    (               reduce using rule 32 (var -> name .)
    {               reduce using rule 32 (var -> name .)
    STRING          reduce using rule 32 (var -> name .)
    ;               reduce using rule 32 (var -> name .)
    LOCAL           reduce using rule 32 (var -> name .)
    FUNCTION        reduce using rule 32 (var -> name .)
    DO              reduce using rule 32 (var -> name .)
    WHILE           reduce using rule 32 (var -> name .)
    REPEAT          reduce using rule 32 (var -> name .)
    FOR             reduce using rule 32 (var -> name .)
    IF              reduce using rule 32 (var -> name .)
    IDENTIFIER      reduce using rule 32 (var -> name .)
    $end            reduce using rule 32 (var -> name .)
    END             reduce using rule 32 (var -> name .)
    UNTIL           reduce using rule 32 (var -> name .)
    ELSEIF          reduce using rule 32 (var -> name .)
    ELSE            reduce using rule 32 (var -> name .)
    CIRCUMFLEX      reduce using rule 32 (var -> name .)
    TIMES           reduce using rule 32 (var -> name .)
    DIVIDE          reduce using rule 32 (var -> name .)
    %               reduce using rule 32 (var -> name .)
    PLUS            reduce using rule 32 (var -> name .)
    MINUS           reduce using rule 32 (var -> name .)
    CONCAT          reduce using rule 32 (var -> name .)
    LT              reduce using rule 32 (var -> name .)
    LTE             reduce using rule 32 (var -> name .)
    GT              reduce using rule 32 (var -> name .)
    GTE             reduce using rule 32 (var -> name .)
    NE              reduce using rule 32 (var -> name .)
    EQUALS          reduce using rule 32 (var -> name .)
    AND             reduce using rule 32 (var -> name .)
    OR              reduce using rule 32 (var -> name .)
    THEN            reduce using rule 32 (var -> name .)
    )               reduce using rule 32 (var -> name .)
    }               reduce using rule 32 (var -> name .)
    RETURN          reduce using rule 32 (var -> name .)
    BREAK           reduce using rule 32 (var -> name .)
    ]               reduce using rule 32 (var -> name .)


state 12

    (17) stat -> functioncall .
    (57) prefixexp -> functioncall .

  ! reduce/reduce conflict for ( resolved using rule 17 (stat -> functioncall .)
    ;               reduce using rule 17 (stat -> functioncall .)
    RETURN          reduce using rule 17 (stat -> functioncall .)
    BREAK           reduce using rule 17 (stat -> functioncall .)
    LOCAL           reduce using rule 17 (stat -> functioncall .)
    FUNCTION        reduce using rule 17 (stat -> functioncall .)
    DO              reduce using rule 17 (stat -> functioncall .)
    WHILE           reduce using rule 17 (stat -> functioncall .)
    REPEAT          reduce using rule 17 (stat -> functioncall .)
    FOR             reduce using rule 17 (stat -> functioncall .)
    IF              reduce using rule 17 (stat -> functioncall .)
    (               reduce using rule 17 (stat -> functioncall .)
    IDENTIFIER      reduce using rule 17 (stat -> functioncall .)
    $end            reduce using rule 17 (stat -> functioncall .)
    END             reduce using rule 17 (stat -> functioncall .)
    UNTIL           reduce using rule 17 (stat -> functioncall .)
    ELSEIF          reduce using rule 17 (stat -> functioncall .)
    ELSE            reduce using rule 17 (stat -> functioncall .)
    :               reduce using rule 57 (prefixexp -> functioncall .)
    [               reduce using rule 57 (prefixexp -> functioncall .)
    .               reduce using rule 57 (prefixexp -> functioncall .)
    {               reduce using rule 57 (prefixexp -> functioncall .)
    STRING          reduce using rule 57 (prefixexp -> functioncall .)

  ! (               [ reduce using rule 57 (prefixexp -> functioncall .) ]


state 13

    (18) stat -> DO . block END
    (1) block -> . chunk
    (2) chunk -> . chunk2 laststat
    (3) chunk -> . chunk2
    (4) chunk -> . laststat
    (5) chunk2 -> . stat optsemi
    (6) chunk2 -> . chunk stat optsemi
    (9) laststat -> . RETURN explist optsemi
    (10) laststat -> . RETURN optsemi
    (11) laststat -> . BREAK optsemi
    (12) stat -> . varlist = explist
    (13) stat -> . LOCAL namelist = explist
    (14) stat -> . LOCAL namelist
    (15) stat -> . FUNCTION funcname funcbody
    (16) stat -> . LOCAL FUNCTION name funcbody
    (17) stat -> . functioncall
    (18) stat -> . DO block END
    (19) stat -> . WHILE exp DO block END
    (20) stat -> . REPEAT block UNTIL exp
    (21) stat -> . if elseiflist else END
    (22) stat -> . FOR name = exp , exp DO block END
    (23) stat -> . FOR name = exp , exp , exp DO block END
    (24) stat -> . FOR namelist IN explist DO block END
    (35) varlist -> . var
    (36) varlist -> . varlist , var
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (25) if -> . IF exp THEN block
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (37) name -> . IDENTIFIER

    RETURN          shift and go to state 6
    BREAK           shift and go to state 7
    LOCAL           shift and go to state 9
    FUNCTION        shift and go to state 10
    DO              shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    FOR             shift and go to state 17
    IF              shift and go to state 20
    (               shift and go to state 21
    IDENTIFIER      shift and go to state 22

    block                          shift and go to state 67
    chunk                          shift and go to state 2
    chunk2                         shift and go to state 3
    laststat                       shift and go to state 4
    stat                           shift and go to state 5
    varlist                        shift and go to state 8
    name                           shift and go to state 11
    functioncall                   shift and go to state 12
    if                             shift and go to state 16
    var                            shift and go to state 18
    prefixexp                      shift and go to state 19

state 14

    (19) stat -> WHILE . exp DO block END
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp

    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    exp                            shift and go to state 68
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57

state 15

    (20) stat -> REPEAT . block UNTIL exp
    (1) block -> . chunk
    (2) chunk -> . chunk2 laststat
    (3) chunk -> . chunk2
    (4) chunk -> . laststat
    (5) chunk2 -> . stat optsemi
    (6) chunk2 -> . chunk stat optsemi
    (9) laststat -> . RETURN explist optsemi
    (10) laststat -> . RETURN optsemi
    (11) laststat -> . BREAK optsemi
    (12) stat -> . varlist = explist
    (13) stat -> . LOCAL namelist = explist
    (14) stat -> . LOCAL namelist
    (15) stat -> . FUNCTION funcname funcbody
    (16) stat -> . LOCAL FUNCTION name funcbody
    (17) stat -> . functioncall
    (18) stat -> . DO block END
    (19) stat -> . WHILE exp DO block END
    (20) stat -> . REPEAT block UNTIL exp
    (21) stat -> . if elseiflist else END
    (22) stat -> . FOR name = exp , exp DO block END
    (23) stat -> . FOR name = exp , exp , exp DO block END
    (24) stat -> . FOR namelist IN explist DO block END
    (35) varlist -> . var
    (36) varlist -> . varlist , var
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (25) if -> . IF exp THEN block
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (37) name -> . IDENTIFIER

    RETURN          shift and go to state 6
    BREAK           shift and go to state 7
    LOCAL           shift and go to state 9
    FUNCTION        shift and go to state 10
    DO              shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    FOR             shift and go to state 17
    IF              shift and go to state 20
    (               shift and go to state 21
    IDENTIFIER      shift and go to state 22

    block                          shift and go to state 69
    chunk                          shift and go to state 2
    chunk2                         shift and go to state 3
    laststat                       shift and go to state 4
    stat                           shift and go to state 5
    varlist                        shift and go to state 8
    name                           shift and go to state 11
    functioncall                   shift and go to state 12
    if                             shift and go to state 16
    var                            shift and go to state 18
    prefixexp                      shift and go to state 19

state 16

    (21) stat -> if . elseiflist else END
    (26) elseiflist -> . elseif
    (27) elseiflist -> . elseiflist elseif
    (28) elseiflist -> . empty
    (29) elseif -> . ELSEIF exp THEN block
    (113) empty -> .

  ! shift/reduce conflict for ELSEIF resolved as shift
    ELSEIF          shift and go to state 73
    ELSE            reduce using rule 113 (empty -> .)
    END             reduce using rule 113 (empty -> .)

  ! ELSEIF          [ reduce using rule 113 (empty -> .) ]

    elseiflist                     shift and go to state 70
    elseif                         shift and go to state 71
    empty                          shift and go to state 72

state 17

    (22) stat -> FOR . name = exp , exp DO block END
    (23) stat -> FOR . name = exp , exp , exp DO block END
    (24) stat -> FOR . namelist IN explist DO block END
    (37) name -> . IDENTIFIER
    (42) namelist -> . name
    (43) namelist -> . namelist , name

    IDENTIFIER      shift and go to state 22

    name                           shift and go to state 74
    namelist                       shift and go to state 75

state 18

    (35) varlist -> var .
    (56) prefixexp -> var .

    =               reduce using rule 35 (varlist -> var .)
    ,               reduce using rule 35 (varlist -> var .)
    :               reduce using rule 56 (prefixexp -> var .)
    [               reduce using rule 56 (prefixexp -> var .)
    .               reduce using rule 56 (prefixexp -> var .)
    (               reduce using rule 56 (prefixexp -> var .)
    {               reduce using rule 56 (prefixexp -> var .)
    STRING          reduce using rule 56 (prefixexp -> var .)


state 19

    (60) functioncall -> prefixexp . args
    (61) functioncall -> prefixexp . : name args
    (33) var -> prefixexp . [ exp ]
    (34) var -> prefixexp . . name
    (68) args -> . ( )
    (69) args -> . ( explist )
    (70) args -> . tableconstructor
    (71) args -> . string
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (84) string -> . STRING

    :               shift and go to state 77
    [               shift and go to state 78
    .               shift and go to state 79
    (               shift and go to state 80
    {               shift and go to state 45
    STRING          shift and go to state 41

    args                           shift and go to state 76
    tableconstructor               shift and go to state 81
    string                         shift and go to state 82

state 20

    (25) if -> IF . exp THEN block
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp

    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    exp                            shift and go to state 83
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57

state 21

    (58) prefixexp -> ( . exp )
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp

    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    exp                            shift and go to state 84
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57

state 22

    (37) name -> IDENTIFIER .

    =               reduce using rule 37 (name -> IDENTIFIER .)
    ,               reduce using rule 37 (name -> IDENTIFIER .)
    :               reduce using rule 37 (name -> IDENTIFIER .)
    [               reduce using rule 37 (name -> IDENTIFIER .)
    .               reduce using rule 37 (name -> IDENTIFIER .)
    (               reduce using rule 37 (name -> IDENTIFIER .)
    {               reduce using rule 37 (name -> IDENTIFIER .)
    STRING          reduce using rule 37 (name -> IDENTIFIER .)
    ;               reduce using rule 37 (name -> IDENTIFIER .)
    LOCAL           reduce using rule 37 (name -> IDENTIFIER .)
    FUNCTION        reduce using rule 37 (name -> IDENTIFIER .)
    DO              reduce using rule 37 (name -> IDENTIFIER .)
    WHILE           reduce using rule 37 (name -> IDENTIFIER .)
    REPEAT          reduce using rule 37 (name -> IDENTIFIER .)
    FOR             reduce using rule 37 (name -> IDENTIFIER .)
    IF              reduce using rule 37 (name -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 37 (name -> IDENTIFIER .)
    $end            reduce using rule 37 (name -> IDENTIFIER .)
    END             reduce using rule 37 (name -> IDENTIFIER .)
    UNTIL           reduce using rule 37 (name -> IDENTIFIER .)
    ELSEIF          reduce using rule 37 (name -> IDENTIFIER .)
    ELSE            reduce using rule 37 (name -> IDENTIFIER .)
    CIRCUMFLEX      reduce using rule 37 (name -> IDENTIFIER .)
    TIMES           reduce using rule 37 (name -> IDENTIFIER .)
    DIVIDE          reduce using rule 37 (name -> IDENTIFIER .)
    %               reduce using rule 37 (name -> IDENTIFIER .)
    PLUS            reduce using rule 37 (name -> IDENTIFIER .)
    MINUS           reduce using rule 37 (name -> IDENTIFIER .)
    CONCAT          reduce using rule 37 (name -> IDENTIFIER .)
    LT              reduce using rule 37 (name -> IDENTIFIER .)
    LTE             reduce using rule 37 (name -> IDENTIFIER .)
    GT              reduce using rule 37 (name -> IDENTIFIER .)
    GTE             reduce using rule 37 (name -> IDENTIFIER .)
    NE              reduce using rule 37 (name -> IDENTIFIER .)
    EQUALS          reduce using rule 37 (name -> IDENTIFIER .)
    AND             reduce using rule 37 (name -> IDENTIFIER .)
    OR              reduce using rule 37 (name -> IDENTIFIER .)
    RETURN          reduce using rule 37 (name -> IDENTIFIER .)
    BREAK           reduce using rule 37 (name -> IDENTIFIER .)
    IN              reduce using rule 37 (name -> IDENTIFIER .)
    THEN            reduce using rule 37 (name -> IDENTIFIER .)
    )               reduce using rule 37 (name -> IDENTIFIER .)
    }               reduce using rule 37 (name -> IDENTIFIER .)
    ]               reduce using rule 37 (name -> IDENTIFIER .)


state 23

    (6) chunk2 -> chunk stat . optsemi
    (7) optsemi -> . ;
    (8) optsemi -> . empty
    (113) empty -> .

    ;               shift and go to state 26
    RETURN          reduce using rule 113 (empty -> .)
    BREAK           reduce using rule 113 (empty -> .)
    LOCAL           reduce using rule 113 (empty -> .)
    FUNCTION        reduce using rule 113 (empty -> .)
    DO              reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    REPEAT          reduce using rule 113 (empty -> .)
    FOR             reduce using rule 113 (empty -> .)
    IF              reduce using rule 113 (empty -> .)
    (               reduce using rule 113 (empty -> .)
    IDENTIFIER      reduce using rule 113 (empty -> .)
    $end            reduce using rule 113 (empty -> .)
    END             reduce using rule 113 (empty -> .)
    UNTIL           reduce using rule 113 (empty -> .)
    ELSEIF          reduce using rule 113 (empty -> .)
    ELSE            reduce using rule 113 (empty -> .)

    optsemi                        shift and go to state 85
    empty                          shift and go to state 27

state 24

    (2) chunk -> chunk2 laststat .

    LOCAL           reduce using rule 2 (chunk -> chunk2 laststat .)
    FUNCTION        reduce using rule 2 (chunk -> chunk2 laststat .)
    DO              reduce using rule 2 (chunk -> chunk2 laststat .)
    WHILE           reduce using rule 2 (chunk -> chunk2 laststat .)
    REPEAT          reduce using rule 2 (chunk -> chunk2 laststat .)
    FOR             reduce using rule 2 (chunk -> chunk2 laststat .)
    IF              reduce using rule 2 (chunk -> chunk2 laststat .)
    (               reduce using rule 2 (chunk -> chunk2 laststat .)
    IDENTIFIER      reduce using rule 2 (chunk -> chunk2 laststat .)
    $end            reduce using rule 2 (chunk -> chunk2 laststat .)
    END             reduce using rule 2 (chunk -> chunk2 laststat .)
    UNTIL           reduce using rule 2 (chunk -> chunk2 laststat .)
    ELSEIF          reduce using rule 2 (chunk -> chunk2 laststat .)
    ELSE            reduce using rule 2 (chunk -> chunk2 laststat .)


state 25

    (5) chunk2 -> stat optsemi .

    RETURN          reduce using rule 5 (chunk2 -> stat optsemi .)
    BREAK           reduce using rule 5 (chunk2 -> stat optsemi .)
    LOCAL           reduce using rule 5 (chunk2 -> stat optsemi .)
    FUNCTION        reduce using rule 5 (chunk2 -> stat optsemi .)
    DO              reduce using rule 5 (chunk2 -> stat optsemi .)
    WHILE           reduce using rule 5 (chunk2 -> stat optsemi .)
    REPEAT          reduce using rule 5 (chunk2 -> stat optsemi .)
    FOR             reduce using rule 5 (chunk2 -> stat optsemi .)
    IF              reduce using rule 5 (chunk2 -> stat optsemi .)
    (               reduce using rule 5 (chunk2 -> stat optsemi .)
    IDENTIFIER      reduce using rule 5 (chunk2 -> stat optsemi .)
    $end            reduce using rule 5 (chunk2 -> stat optsemi .)
    END             reduce using rule 5 (chunk2 -> stat optsemi .)
    UNTIL           reduce using rule 5 (chunk2 -> stat optsemi .)
    ELSEIF          reduce using rule 5 (chunk2 -> stat optsemi .)
    ELSE            reduce using rule 5 (chunk2 -> stat optsemi .)


state 26

    (7) optsemi -> ; .

    RETURN          reduce using rule 7 (optsemi -> ; .)
    BREAK           reduce using rule 7 (optsemi -> ; .)
    LOCAL           reduce using rule 7 (optsemi -> ; .)
    FUNCTION        reduce using rule 7 (optsemi -> ; .)
    DO              reduce using rule 7 (optsemi -> ; .)
    WHILE           reduce using rule 7 (optsemi -> ; .)
    REPEAT          reduce using rule 7 (optsemi -> ; .)
    FOR             reduce using rule 7 (optsemi -> ; .)
    IF              reduce using rule 7 (optsemi -> ; .)
    (               reduce using rule 7 (optsemi -> ; .)
    IDENTIFIER      reduce using rule 7 (optsemi -> ; .)
    $end            reduce using rule 7 (optsemi -> ; .)
    END             reduce using rule 7 (optsemi -> ; .)
    UNTIL           reduce using rule 7 (optsemi -> ; .)
    ELSEIF          reduce using rule 7 (optsemi -> ; .)
    ELSE            reduce using rule 7 (optsemi -> ; .)


state 27

    (8) optsemi -> empty .

    RETURN          reduce using rule 8 (optsemi -> empty .)
    BREAK           reduce using rule 8 (optsemi -> empty .)
    LOCAL           reduce using rule 8 (optsemi -> empty .)
    FUNCTION        reduce using rule 8 (optsemi -> empty .)
    DO              reduce using rule 8 (optsemi -> empty .)
    WHILE           reduce using rule 8 (optsemi -> empty .)
    REPEAT          reduce using rule 8 (optsemi -> empty .)
    FOR             reduce using rule 8 (optsemi -> empty .)
    IF              reduce using rule 8 (optsemi -> empty .)
    (               reduce using rule 8 (optsemi -> empty .)
    IDENTIFIER      reduce using rule 8 (optsemi -> empty .)
    $end            reduce using rule 8 (optsemi -> empty .)
    END             reduce using rule 8 (optsemi -> empty .)
    UNTIL           reduce using rule 8 (optsemi -> empty .)
    ELSEIF          reduce using rule 8 (optsemi -> empty .)
    ELSE            reduce using rule 8 (optsemi -> empty .)


state 28

    (9) laststat -> RETURN explist . optsemi
    (55) explist -> explist . , exp
    (7) optsemi -> . ;
    (8) optsemi -> . empty
    (113) empty -> .

    ,               shift and go to state 87
    ;               shift and go to state 26
    LOCAL           reduce using rule 113 (empty -> .)
    FUNCTION        reduce using rule 113 (empty -> .)
    DO              reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    REPEAT          reduce using rule 113 (empty -> .)
    FOR             reduce using rule 113 (empty -> .)
    IF              reduce using rule 113 (empty -> .)
    (               reduce using rule 113 (empty -> .)
    IDENTIFIER      reduce using rule 113 (empty -> .)
    $end            reduce using rule 113 (empty -> .)
    END             reduce using rule 113 (empty -> .)
    UNTIL           reduce using rule 113 (empty -> .)
    ELSEIF          reduce using rule 113 (empty -> .)
    ELSE            reduce using rule 113 (empty -> .)

    optsemi                        shift and go to state 86
    empty                          shift and go to state 27

state 29

    (10) laststat -> RETURN optsemi .

    LOCAL           reduce using rule 10 (laststat -> RETURN optsemi .)
    FUNCTION        reduce using rule 10 (laststat -> RETURN optsemi .)
    DO              reduce using rule 10 (laststat -> RETURN optsemi .)
    WHILE           reduce using rule 10 (laststat -> RETURN optsemi .)
    REPEAT          reduce using rule 10 (laststat -> RETURN optsemi .)
    FOR             reduce using rule 10 (laststat -> RETURN optsemi .)
    IF              reduce using rule 10 (laststat -> RETURN optsemi .)
    (               reduce using rule 10 (laststat -> RETURN optsemi .)
    IDENTIFIER      reduce using rule 10 (laststat -> RETURN optsemi .)
    $end            reduce using rule 10 (laststat -> RETURN optsemi .)
    END             reduce using rule 10 (laststat -> RETURN optsemi .)
    UNTIL           reduce using rule 10 (laststat -> RETURN optsemi .)
    ELSEIF          reduce using rule 10 (laststat -> RETURN optsemi .)
    ELSE            reduce using rule 10 (laststat -> RETURN optsemi .)


state 30

    (54) explist -> exp .
    (112) op_9 -> exp .

  ! reduce/reduce conflict for , resolved using rule 54 (explist -> exp .)
  ! reduce/reduce conflict for ; resolved using rule 54 (explist -> exp .)
  ! reduce/reduce conflict for LOCAL resolved using rule 54 (explist -> exp .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 54 (explist -> exp .)
  ! reduce/reduce conflict for DO resolved using rule 54 (explist -> exp .)
  ! reduce/reduce conflict for WHILE resolved using rule 54 (explist -> exp .)
  ! reduce/reduce conflict for REPEAT resolved using rule 54 (explist -> exp .)
  ! reduce/reduce conflict for FOR resolved using rule 54 (explist -> exp .)
  ! reduce/reduce conflict for IF resolved using rule 54 (explist -> exp .)
  ! reduce/reduce conflict for ( resolved using rule 54 (explist -> exp .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 54 (explist -> exp .)
  ! reduce/reduce conflict for $end resolved using rule 54 (explist -> exp .)
  ! reduce/reduce conflict for END resolved using rule 54 (explist -> exp .)
  ! reduce/reduce conflict for UNTIL resolved using rule 54 (explist -> exp .)
  ! reduce/reduce conflict for ELSEIF resolved using rule 54 (explist -> exp .)
  ! reduce/reduce conflict for ELSE resolved using rule 54 (explist -> exp .)
  ! reduce/reduce conflict for RETURN resolved using rule 54 (explist -> exp .)
  ! reduce/reduce conflict for BREAK resolved using rule 54 (explist -> exp .)
  ! reduce/reduce conflict for ) resolved using rule 54 (explist -> exp .)
    ,               reduce using rule 54 (explist -> exp .)
    ;               reduce using rule 54 (explist -> exp .)
    LOCAL           reduce using rule 54 (explist -> exp .)
    FUNCTION        reduce using rule 54 (explist -> exp .)
    DO              reduce using rule 54 (explist -> exp .)
    WHILE           reduce using rule 54 (explist -> exp .)
    REPEAT          reduce using rule 54 (explist -> exp .)
    FOR             reduce using rule 54 (explist -> exp .)
    IF              reduce using rule 54 (explist -> exp .)
    (               reduce using rule 54 (explist -> exp .)
    IDENTIFIER      reduce using rule 54 (explist -> exp .)
    $end            reduce using rule 54 (explist -> exp .)
    END             reduce using rule 54 (explist -> exp .)
    UNTIL           reduce using rule 54 (explist -> exp .)
    ELSEIF          reduce using rule 54 (explist -> exp .)
    ELSE            reduce using rule 54 (explist -> exp .)
    RETURN          reduce using rule 54 (explist -> exp .)
    BREAK           reduce using rule 54 (explist -> exp .)
    )               reduce using rule 54 (explist -> exp .)
    CIRCUMFLEX      reduce using rule 112 (op_9 -> exp .)
    TIMES           reduce using rule 112 (op_9 -> exp .)
    DIVIDE          reduce using rule 112 (op_9 -> exp .)
    %               reduce using rule 112 (op_9 -> exp .)
    PLUS            reduce using rule 112 (op_9 -> exp .)
    MINUS           reduce using rule 112 (op_9 -> exp .)
    CONCAT          reduce using rule 112 (op_9 -> exp .)
    LT              reduce using rule 112 (op_9 -> exp .)
    LTE             reduce using rule 112 (op_9 -> exp .)
    GT              reduce using rule 112 (op_9 -> exp .)
    GTE             reduce using rule 112 (op_9 -> exp .)
    NE              reduce using rule 112 (op_9 -> exp .)
    EQUALS          reduce using rule 112 (op_9 -> exp .)
    AND             reduce using rule 112 (op_9 -> exp .)
    OR              reduce using rule 112 (op_9 -> exp .)

  ! ,               [ reduce using rule 112 (op_9 -> exp .) ]
  ! ;               [ reduce using rule 112 (op_9 -> exp .) ]
  ! LOCAL           [ reduce using rule 112 (op_9 -> exp .) ]
  ! FUNCTION        [ reduce using rule 112 (op_9 -> exp .) ]
  ! DO              [ reduce using rule 112 (op_9 -> exp .) ]
  ! WHILE           [ reduce using rule 112 (op_9 -> exp .) ]
  ! REPEAT          [ reduce using rule 112 (op_9 -> exp .) ]
  ! FOR             [ reduce using rule 112 (op_9 -> exp .) ]
  ! IF              [ reduce using rule 112 (op_9 -> exp .) ]
  ! (               [ reduce using rule 112 (op_9 -> exp .) ]
  ! IDENTIFIER      [ reduce using rule 112 (op_9 -> exp .) ]
  ! $end            [ reduce using rule 112 (op_9 -> exp .) ]
  ! END             [ reduce using rule 112 (op_9 -> exp .) ]
  ! UNTIL           [ reduce using rule 112 (op_9 -> exp .) ]
  ! ELSEIF          [ reduce using rule 112 (op_9 -> exp .) ]
  ! ELSE            [ reduce using rule 112 (op_9 -> exp .) ]
  ! RETURN          [ reduce using rule 112 (op_9 -> exp .) ]
  ! BREAK           [ reduce using rule 112 (op_9 -> exp .) ]
  ! )               [ reduce using rule 112 (op_9 -> exp .) ]


state 31

    (44) exp -> NIL .

    ,               reduce using rule 44 (exp -> NIL .)
    ;               reduce using rule 44 (exp -> NIL .)
    LOCAL           reduce using rule 44 (exp -> NIL .)
    FUNCTION        reduce using rule 44 (exp -> NIL .)
    DO              reduce using rule 44 (exp -> NIL .)
    WHILE           reduce using rule 44 (exp -> NIL .)
    REPEAT          reduce using rule 44 (exp -> NIL .)
    FOR             reduce using rule 44 (exp -> NIL .)
    IF              reduce using rule 44 (exp -> NIL .)
    (               reduce using rule 44 (exp -> NIL .)
    IDENTIFIER      reduce using rule 44 (exp -> NIL .)
    $end            reduce using rule 44 (exp -> NIL .)
    END             reduce using rule 44 (exp -> NIL .)
    UNTIL           reduce using rule 44 (exp -> NIL .)
    ELSEIF          reduce using rule 44 (exp -> NIL .)
    ELSE            reduce using rule 44 (exp -> NIL .)
    CIRCUMFLEX      reduce using rule 44 (exp -> NIL .)
    TIMES           reduce using rule 44 (exp -> NIL .)
    DIVIDE          reduce using rule 44 (exp -> NIL .)
    %               reduce using rule 44 (exp -> NIL .)
    PLUS            reduce using rule 44 (exp -> NIL .)
    MINUS           reduce using rule 44 (exp -> NIL .)
    CONCAT          reduce using rule 44 (exp -> NIL .)
    LT              reduce using rule 44 (exp -> NIL .)
    LTE             reduce using rule 44 (exp -> NIL .)
    GT              reduce using rule 44 (exp -> NIL .)
    GTE             reduce using rule 44 (exp -> NIL .)
    NE              reduce using rule 44 (exp -> NIL .)
    EQUALS          reduce using rule 44 (exp -> NIL .)
    AND             reduce using rule 44 (exp -> NIL .)
    OR              reduce using rule 44 (exp -> NIL .)
    THEN            reduce using rule 44 (exp -> NIL .)
    )               reduce using rule 44 (exp -> NIL .)
    }               reduce using rule 44 (exp -> NIL .)
    RETURN          reduce using rule 44 (exp -> NIL .)
    BREAK           reduce using rule 44 (exp -> NIL .)
    ]               reduce using rule 44 (exp -> NIL .)


state 32

    (45) exp -> FALSE .

    ,               reduce using rule 45 (exp -> FALSE .)
    ;               reduce using rule 45 (exp -> FALSE .)
    LOCAL           reduce using rule 45 (exp -> FALSE .)
    FUNCTION        reduce using rule 45 (exp -> FALSE .)
    DO              reduce using rule 45 (exp -> FALSE .)
    WHILE           reduce using rule 45 (exp -> FALSE .)
    REPEAT          reduce using rule 45 (exp -> FALSE .)
    FOR             reduce using rule 45 (exp -> FALSE .)
    IF              reduce using rule 45 (exp -> FALSE .)
    (               reduce using rule 45 (exp -> FALSE .)
    IDENTIFIER      reduce using rule 45 (exp -> FALSE .)
    $end            reduce using rule 45 (exp -> FALSE .)
    END             reduce using rule 45 (exp -> FALSE .)
    UNTIL           reduce using rule 45 (exp -> FALSE .)
    ELSEIF          reduce using rule 45 (exp -> FALSE .)
    ELSE            reduce using rule 45 (exp -> FALSE .)
    CIRCUMFLEX      reduce using rule 45 (exp -> FALSE .)
    TIMES           reduce using rule 45 (exp -> FALSE .)
    DIVIDE          reduce using rule 45 (exp -> FALSE .)
    %               reduce using rule 45 (exp -> FALSE .)
    PLUS            reduce using rule 45 (exp -> FALSE .)
    MINUS           reduce using rule 45 (exp -> FALSE .)
    CONCAT          reduce using rule 45 (exp -> FALSE .)
    LT              reduce using rule 45 (exp -> FALSE .)
    LTE             reduce using rule 45 (exp -> FALSE .)
    GT              reduce using rule 45 (exp -> FALSE .)
    GTE             reduce using rule 45 (exp -> FALSE .)
    NE              reduce using rule 45 (exp -> FALSE .)
    EQUALS          reduce using rule 45 (exp -> FALSE .)
    AND             reduce using rule 45 (exp -> FALSE .)
    OR              reduce using rule 45 (exp -> FALSE .)
    THEN            reduce using rule 45 (exp -> FALSE .)
    )               reduce using rule 45 (exp -> FALSE .)
    }               reduce using rule 45 (exp -> FALSE .)
    RETURN          reduce using rule 45 (exp -> FALSE .)
    BREAK           reduce using rule 45 (exp -> FALSE .)
    ]               reduce using rule 45 (exp -> FALSE .)


state 33

    (46) exp -> TRUE .

    ,               reduce using rule 46 (exp -> TRUE .)
    ;               reduce using rule 46 (exp -> TRUE .)
    LOCAL           reduce using rule 46 (exp -> TRUE .)
    FUNCTION        reduce using rule 46 (exp -> TRUE .)
    DO              reduce using rule 46 (exp -> TRUE .)
    WHILE           reduce using rule 46 (exp -> TRUE .)
    REPEAT          reduce using rule 46 (exp -> TRUE .)
    FOR             reduce using rule 46 (exp -> TRUE .)
    IF              reduce using rule 46 (exp -> TRUE .)
    (               reduce using rule 46 (exp -> TRUE .)
    IDENTIFIER      reduce using rule 46 (exp -> TRUE .)
    $end            reduce using rule 46 (exp -> TRUE .)
    END             reduce using rule 46 (exp -> TRUE .)
    UNTIL           reduce using rule 46 (exp -> TRUE .)
    ELSEIF          reduce using rule 46 (exp -> TRUE .)
    ELSE            reduce using rule 46 (exp -> TRUE .)
    CIRCUMFLEX      reduce using rule 46 (exp -> TRUE .)
    TIMES           reduce using rule 46 (exp -> TRUE .)
    DIVIDE          reduce using rule 46 (exp -> TRUE .)
    %               reduce using rule 46 (exp -> TRUE .)
    PLUS            reduce using rule 46 (exp -> TRUE .)
    MINUS           reduce using rule 46 (exp -> TRUE .)
    CONCAT          reduce using rule 46 (exp -> TRUE .)
    LT              reduce using rule 46 (exp -> TRUE .)
    LTE             reduce using rule 46 (exp -> TRUE .)
    GT              reduce using rule 46 (exp -> TRUE .)
    GTE             reduce using rule 46 (exp -> TRUE .)
    NE              reduce using rule 46 (exp -> TRUE .)
    EQUALS          reduce using rule 46 (exp -> TRUE .)
    AND             reduce using rule 46 (exp -> TRUE .)
    OR              reduce using rule 46 (exp -> TRUE .)
    THEN            reduce using rule 46 (exp -> TRUE .)
    )               reduce using rule 46 (exp -> TRUE .)
    }               reduce using rule 46 (exp -> TRUE .)
    RETURN          reduce using rule 46 (exp -> TRUE .)
    BREAK           reduce using rule 46 (exp -> TRUE .)
    ]               reduce using rule 46 (exp -> TRUE .)


state 34

    (47) exp -> NUMBER .

    ,               reduce using rule 47 (exp -> NUMBER .)
    ;               reduce using rule 47 (exp -> NUMBER .)
    LOCAL           reduce using rule 47 (exp -> NUMBER .)
    FUNCTION        reduce using rule 47 (exp -> NUMBER .)
    DO              reduce using rule 47 (exp -> NUMBER .)
    WHILE           reduce using rule 47 (exp -> NUMBER .)
    REPEAT          reduce using rule 47 (exp -> NUMBER .)
    FOR             reduce using rule 47 (exp -> NUMBER .)
    IF              reduce using rule 47 (exp -> NUMBER .)
    (               reduce using rule 47 (exp -> NUMBER .)
    IDENTIFIER      reduce using rule 47 (exp -> NUMBER .)
    $end            reduce using rule 47 (exp -> NUMBER .)
    END             reduce using rule 47 (exp -> NUMBER .)
    UNTIL           reduce using rule 47 (exp -> NUMBER .)
    ELSEIF          reduce using rule 47 (exp -> NUMBER .)
    ELSE            reduce using rule 47 (exp -> NUMBER .)
    CIRCUMFLEX      reduce using rule 47 (exp -> NUMBER .)
    TIMES           reduce using rule 47 (exp -> NUMBER .)
    DIVIDE          reduce using rule 47 (exp -> NUMBER .)
    %               reduce using rule 47 (exp -> NUMBER .)
    PLUS            reduce using rule 47 (exp -> NUMBER .)
    MINUS           reduce using rule 47 (exp -> NUMBER .)
    CONCAT          reduce using rule 47 (exp -> NUMBER .)
    LT              reduce using rule 47 (exp -> NUMBER .)
    LTE             reduce using rule 47 (exp -> NUMBER .)
    GT              reduce using rule 47 (exp -> NUMBER .)
    GTE             reduce using rule 47 (exp -> NUMBER .)
    NE              reduce using rule 47 (exp -> NUMBER .)
    EQUALS          reduce using rule 47 (exp -> NUMBER .)
    AND             reduce using rule 47 (exp -> NUMBER .)
    OR              reduce using rule 47 (exp -> NUMBER .)
    THEN            reduce using rule 47 (exp -> NUMBER .)
    )               reduce using rule 47 (exp -> NUMBER .)
    }               reduce using rule 47 (exp -> NUMBER .)
    RETURN          reduce using rule 47 (exp -> NUMBER .)
    BREAK           reduce using rule 47 (exp -> NUMBER .)
    ]               reduce using rule 47 (exp -> NUMBER .)


state 35

    (48) exp -> string .

    ,               reduce using rule 48 (exp -> string .)
    ;               reduce using rule 48 (exp -> string .)
    LOCAL           reduce using rule 48 (exp -> string .)
    FUNCTION        reduce using rule 48 (exp -> string .)
    DO              reduce using rule 48 (exp -> string .)
    WHILE           reduce using rule 48 (exp -> string .)
    REPEAT          reduce using rule 48 (exp -> string .)
    FOR             reduce using rule 48 (exp -> string .)
    IF              reduce using rule 48 (exp -> string .)
    (               reduce using rule 48 (exp -> string .)
    IDENTIFIER      reduce using rule 48 (exp -> string .)
    $end            reduce using rule 48 (exp -> string .)
    END             reduce using rule 48 (exp -> string .)
    UNTIL           reduce using rule 48 (exp -> string .)
    ELSEIF          reduce using rule 48 (exp -> string .)
    ELSE            reduce using rule 48 (exp -> string .)
    CIRCUMFLEX      reduce using rule 48 (exp -> string .)
    TIMES           reduce using rule 48 (exp -> string .)
    DIVIDE          reduce using rule 48 (exp -> string .)
    %               reduce using rule 48 (exp -> string .)
    PLUS            reduce using rule 48 (exp -> string .)
    MINUS           reduce using rule 48 (exp -> string .)
    CONCAT          reduce using rule 48 (exp -> string .)
    LT              reduce using rule 48 (exp -> string .)
    LTE             reduce using rule 48 (exp -> string .)
    GT              reduce using rule 48 (exp -> string .)
    GTE             reduce using rule 48 (exp -> string .)
    NE              reduce using rule 48 (exp -> string .)
    EQUALS          reduce using rule 48 (exp -> string .)
    AND             reduce using rule 48 (exp -> string .)
    OR              reduce using rule 48 (exp -> string .)
    THEN            reduce using rule 48 (exp -> string .)
    )               reduce using rule 48 (exp -> string .)
    }               reduce using rule 48 (exp -> string .)
    RETURN          reduce using rule 48 (exp -> string .)
    BREAK           reduce using rule 48 (exp -> string .)
    ]               reduce using rule 48 (exp -> string .)


state 36

    (49) exp -> TDOT .

    ,               reduce using rule 49 (exp -> TDOT .)
    ;               reduce using rule 49 (exp -> TDOT .)
    LOCAL           reduce using rule 49 (exp -> TDOT .)
    FUNCTION        reduce using rule 49 (exp -> TDOT .)
    DO              reduce using rule 49 (exp -> TDOT .)
    WHILE           reduce using rule 49 (exp -> TDOT .)
    REPEAT          reduce using rule 49 (exp -> TDOT .)
    FOR             reduce using rule 49 (exp -> TDOT .)
    IF              reduce using rule 49 (exp -> TDOT .)
    (               reduce using rule 49 (exp -> TDOT .)
    IDENTIFIER      reduce using rule 49 (exp -> TDOT .)
    $end            reduce using rule 49 (exp -> TDOT .)
    END             reduce using rule 49 (exp -> TDOT .)
    UNTIL           reduce using rule 49 (exp -> TDOT .)
    ELSEIF          reduce using rule 49 (exp -> TDOT .)
    ELSE            reduce using rule 49 (exp -> TDOT .)
    CIRCUMFLEX      reduce using rule 49 (exp -> TDOT .)
    TIMES           reduce using rule 49 (exp -> TDOT .)
    DIVIDE          reduce using rule 49 (exp -> TDOT .)
    %               reduce using rule 49 (exp -> TDOT .)
    PLUS            reduce using rule 49 (exp -> TDOT .)
    MINUS           reduce using rule 49 (exp -> TDOT .)
    CONCAT          reduce using rule 49 (exp -> TDOT .)
    LT              reduce using rule 49 (exp -> TDOT .)
    LTE             reduce using rule 49 (exp -> TDOT .)
    GT              reduce using rule 49 (exp -> TDOT .)
    GTE             reduce using rule 49 (exp -> TDOT .)
    NE              reduce using rule 49 (exp -> TDOT .)
    EQUALS          reduce using rule 49 (exp -> TDOT .)
    AND             reduce using rule 49 (exp -> TDOT .)
    OR              reduce using rule 49 (exp -> TDOT .)
    THEN            reduce using rule 49 (exp -> TDOT .)
    )               reduce using rule 49 (exp -> TDOT .)
    }               reduce using rule 49 (exp -> TDOT .)
    RETURN          reduce using rule 49 (exp -> TDOT .)
    BREAK           reduce using rule 49 (exp -> TDOT .)
    ]               reduce using rule 49 (exp -> TDOT .)


state 37

    (50) exp -> function .

    ,               reduce using rule 50 (exp -> function .)
    ;               reduce using rule 50 (exp -> function .)
    LOCAL           reduce using rule 50 (exp -> function .)
    FUNCTION        reduce using rule 50 (exp -> function .)
    DO              reduce using rule 50 (exp -> function .)
    WHILE           reduce using rule 50 (exp -> function .)
    REPEAT          reduce using rule 50 (exp -> function .)
    FOR             reduce using rule 50 (exp -> function .)
    IF              reduce using rule 50 (exp -> function .)
    (               reduce using rule 50 (exp -> function .)
    IDENTIFIER      reduce using rule 50 (exp -> function .)
    $end            reduce using rule 50 (exp -> function .)
    END             reduce using rule 50 (exp -> function .)
    UNTIL           reduce using rule 50 (exp -> function .)
    ELSEIF          reduce using rule 50 (exp -> function .)
    ELSE            reduce using rule 50 (exp -> function .)
    CIRCUMFLEX      reduce using rule 50 (exp -> function .)
    TIMES           reduce using rule 50 (exp -> function .)
    DIVIDE          reduce using rule 50 (exp -> function .)
    %               reduce using rule 50 (exp -> function .)
    PLUS            reduce using rule 50 (exp -> function .)
    MINUS           reduce using rule 50 (exp -> function .)
    CONCAT          reduce using rule 50 (exp -> function .)
    LT              reduce using rule 50 (exp -> function .)
    LTE             reduce using rule 50 (exp -> function .)
    GT              reduce using rule 50 (exp -> function .)
    GTE             reduce using rule 50 (exp -> function .)
    NE              reduce using rule 50 (exp -> function .)
    EQUALS          reduce using rule 50 (exp -> function .)
    AND             reduce using rule 50 (exp -> function .)
    OR              reduce using rule 50 (exp -> function .)
    THEN            reduce using rule 50 (exp -> function .)
    )               reduce using rule 50 (exp -> function .)
    }               reduce using rule 50 (exp -> function .)
    RETURN          reduce using rule 50 (exp -> function .)
    BREAK           reduce using rule 50 (exp -> function .)
    ]               reduce using rule 50 (exp -> function .)


state 38

    (51) exp -> prefixexp .
    (33) var -> prefixexp . [ exp ]
    (34) var -> prefixexp . . name
    (60) functioncall -> prefixexp . args
    (61) functioncall -> prefixexp . : name args
    (68) args -> . ( )
    (69) args -> . ( explist )
    (70) args -> . tableconstructor
    (71) args -> . string
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (84) string -> . STRING

  ! shift/reduce conflict for ( resolved as shift
    ,               reduce using rule 51 (exp -> prefixexp .)
    ;               reduce using rule 51 (exp -> prefixexp .)
    LOCAL           reduce using rule 51 (exp -> prefixexp .)
    FUNCTION        reduce using rule 51 (exp -> prefixexp .)
    DO              reduce using rule 51 (exp -> prefixexp .)
    WHILE           reduce using rule 51 (exp -> prefixexp .)
    REPEAT          reduce using rule 51 (exp -> prefixexp .)
    FOR             reduce using rule 51 (exp -> prefixexp .)
    IF              reduce using rule 51 (exp -> prefixexp .)
    IDENTIFIER      reduce using rule 51 (exp -> prefixexp .)
    $end            reduce using rule 51 (exp -> prefixexp .)
    END             reduce using rule 51 (exp -> prefixexp .)
    UNTIL           reduce using rule 51 (exp -> prefixexp .)
    ELSEIF          reduce using rule 51 (exp -> prefixexp .)
    ELSE            reduce using rule 51 (exp -> prefixexp .)
    CIRCUMFLEX      reduce using rule 51 (exp -> prefixexp .)
    TIMES           reduce using rule 51 (exp -> prefixexp .)
    DIVIDE          reduce using rule 51 (exp -> prefixexp .)
    %               reduce using rule 51 (exp -> prefixexp .)
    PLUS            reduce using rule 51 (exp -> prefixexp .)
    MINUS           reduce using rule 51 (exp -> prefixexp .)
    CONCAT          reduce using rule 51 (exp -> prefixexp .)
    LT              reduce using rule 51 (exp -> prefixexp .)
    LTE             reduce using rule 51 (exp -> prefixexp .)
    GT              reduce using rule 51 (exp -> prefixexp .)
    GTE             reduce using rule 51 (exp -> prefixexp .)
    NE              reduce using rule 51 (exp -> prefixexp .)
    EQUALS          reduce using rule 51 (exp -> prefixexp .)
    AND             reduce using rule 51 (exp -> prefixexp .)
    OR              reduce using rule 51 (exp -> prefixexp .)
    THEN            reduce using rule 51 (exp -> prefixexp .)
    )               reduce using rule 51 (exp -> prefixexp .)
    }               reduce using rule 51 (exp -> prefixexp .)
    RETURN          reduce using rule 51 (exp -> prefixexp .)
    BREAK           reduce using rule 51 (exp -> prefixexp .)
    ]               reduce using rule 51 (exp -> prefixexp .)
    [               shift and go to state 78
    .               shift and go to state 79
    :               shift and go to state 77
    (               shift and go to state 80
    {               shift and go to state 45
    STRING          shift and go to state 41

  ! (               [ reduce using rule 51 (exp -> prefixexp .) ]

    args                           shift and go to state 76
    tableconstructor               shift and go to state 81
    string                         shift and go to state 82

state 39

    (52) exp -> tableconstructor .

    ,               reduce using rule 52 (exp -> tableconstructor .)
    ;               reduce using rule 52 (exp -> tableconstructor .)
    LOCAL           reduce using rule 52 (exp -> tableconstructor .)
    FUNCTION        reduce using rule 52 (exp -> tableconstructor .)
    DO              reduce using rule 52 (exp -> tableconstructor .)
    WHILE           reduce using rule 52 (exp -> tableconstructor .)
    REPEAT          reduce using rule 52 (exp -> tableconstructor .)
    FOR             reduce using rule 52 (exp -> tableconstructor .)
    IF              reduce using rule 52 (exp -> tableconstructor .)
    (               reduce using rule 52 (exp -> tableconstructor .)
    IDENTIFIER      reduce using rule 52 (exp -> tableconstructor .)
    $end            reduce using rule 52 (exp -> tableconstructor .)
    END             reduce using rule 52 (exp -> tableconstructor .)
    UNTIL           reduce using rule 52 (exp -> tableconstructor .)
    ELSEIF          reduce using rule 52 (exp -> tableconstructor .)
    ELSE            reduce using rule 52 (exp -> tableconstructor .)
    CIRCUMFLEX      reduce using rule 52 (exp -> tableconstructor .)
    TIMES           reduce using rule 52 (exp -> tableconstructor .)
    DIVIDE          reduce using rule 52 (exp -> tableconstructor .)
    %               reduce using rule 52 (exp -> tableconstructor .)
    PLUS            reduce using rule 52 (exp -> tableconstructor .)
    MINUS           reduce using rule 52 (exp -> tableconstructor .)
    CONCAT          reduce using rule 52 (exp -> tableconstructor .)
    LT              reduce using rule 52 (exp -> tableconstructor .)
    LTE             reduce using rule 52 (exp -> tableconstructor .)
    GT              reduce using rule 52 (exp -> tableconstructor .)
    GTE             reduce using rule 52 (exp -> tableconstructor .)
    NE              reduce using rule 52 (exp -> tableconstructor .)
    EQUALS          reduce using rule 52 (exp -> tableconstructor .)
    AND             reduce using rule 52 (exp -> tableconstructor .)
    OR              reduce using rule 52 (exp -> tableconstructor .)
    THEN            reduce using rule 52 (exp -> tableconstructor .)
    )               reduce using rule 52 (exp -> tableconstructor .)
    }               reduce using rule 52 (exp -> tableconstructor .)
    RETURN          reduce using rule 52 (exp -> tableconstructor .)
    BREAK           reduce using rule 52 (exp -> tableconstructor .)
    ]               reduce using rule 52 (exp -> tableconstructor .)


state 40

    (53) exp -> op .

    ,               reduce using rule 53 (exp -> op .)
    ;               reduce using rule 53 (exp -> op .)
    LOCAL           reduce using rule 53 (exp -> op .)
    FUNCTION        reduce using rule 53 (exp -> op .)
    DO              reduce using rule 53 (exp -> op .)
    WHILE           reduce using rule 53 (exp -> op .)
    REPEAT          reduce using rule 53 (exp -> op .)
    FOR             reduce using rule 53 (exp -> op .)
    IF              reduce using rule 53 (exp -> op .)
    (               reduce using rule 53 (exp -> op .)
    IDENTIFIER      reduce using rule 53 (exp -> op .)
    $end            reduce using rule 53 (exp -> op .)
    END             reduce using rule 53 (exp -> op .)
    UNTIL           reduce using rule 53 (exp -> op .)
    ELSEIF          reduce using rule 53 (exp -> op .)
    ELSE            reduce using rule 53 (exp -> op .)
    CIRCUMFLEX      reduce using rule 53 (exp -> op .)
    TIMES           reduce using rule 53 (exp -> op .)
    DIVIDE          reduce using rule 53 (exp -> op .)
    %               reduce using rule 53 (exp -> op .)
    PLUS            reduce using rule 53 (exp -> op .)
    MINUS           reduce using rule 53 (exp -> op .)
    CONCAT          reduce using rule 53 (exp -> op .)
    LT              reduce using rule 53 (exp -> op .)
    LTE             reduce using rule 53 (exp -> op .)
    GT              reduce using rule 53 (exp -> op .)
    GTE             reduce using rule 53 (exp -> op .)
    NE              reduce using rule 53 (exp -> op .)
    EQUALS          reduce using rule 53 (exp -> op .)
    AND             reduce using rule 53 (exp -> op .)
    OR              reduce using rule 53 (exp -> op .)
    THEN            reduce using rule 53 (exp -> op .)
    )               reduce using rule 53 (exp -> op .)
    }               reduce using rule 53 (exp -> op .)
    RETURN          reduce using rule 53 (exp -> op .)
    BREAK           reduce using rule 53 (exp -> op .)
    ]               reduce using rule 53 (exp -> op .)


state 41

    (84) string -> STRING .

    ,               reduce using rule 84 (string -> STRING .)
    ;               reduce using rule 84 (string -> STRING .)
    LOCAL           reduce using rule 84 (string -> STRING .)
    FUNCTION        reduce using rule 84 (string -> STRING .)
    DO              reduce using rule 84 (string -> STRING .)
    WHILE           reduce using rule 84 (string -> STRING .)
    REPEAT          reduce using rule 84 (string -> STRING .)
    FOR             reduce using rule 84 (string -> STRING .)
    IF              reduce using rule 84 (string -> STRING .)
    (               reduce using rule 84 (string -> STRING .)
    IDENTIFIER      reduce using rule 84 (string -> STRING .)
    $end            reduce using rule 84 (string -> STRING .)
    END             reduce using rule 84 (string -> STRING .)
    UNTIL           reduce using rule 84 (string -> STRING .)
    ELSEIF          reduce using rule 84 (string -> STRING .)
    ELSE            reduce using rule 84 (string -> STRING .)
    CIRCUMFLEX      reduce using rule 84 (string -> STRING .)
    TIMES           reduce using rule 84 (string -> STRING .)
    DIVIDE          reduce using rule 84 (string -> STRING .)
    %               reduce using rule 84 (string -> STRING .)
    PLUS            reduce using rule 84 (string -> STRING .)
    MINUS           reduce using rule 84 (string -> STRING .)
    CONCAT          reduce using rule 84 (string -> STRING .)
    LT              reduce using rule 84 (string -> STRING .)
    LTE             reduce using rule 84 (string -> STRING .)
    GT              reduce using rule 84 (string -> STRING .)
    GTE             reduce using rule 84 (string -> STRING .)
    NE              reduce using rule 84 (string -> STRING .)
    EQUALS          reduce using rule 84 (string -> STRING .)
    AND             reduce using rule 84 (string -> STRING .)
    OR              reduce using rule 84 (string -> STRING .)
    RETURN          reduce using rule 84 (string -> STRING .)
    BREAK           reduce using rule 84 (string -> STRING .)
    :               reduce using rule 84 (string -> STRING .)
    [               reduce using rule 84 (string -> STRING .)
    .               reduce using rule 84 (string -> STRING .)
    {               reduce using rule 84 (string -> STRING .)
    STRING          reduce using rule 84 (string -> STRING .)
    THEN            reduce using rule 84 (string -> STRING .)
    )               reduce using rule 84 (string -> STRING .)
    }               reduce using rule 84 (string -> STRING .)
    ]               reduce using rule 84 (string -> STRING .)


state 42

    (59) function -> FUNCTION . funcbody
    (63) funcbody -> . ( parlist ) block END
    (64) funcbody -> . ( ) block END

    (               shift and go to state 89

    funcbody                       shift and go to state 88

state 43

    (56) prefixexp -> var .

    [               reduce using rule 56 (prefixexp -> var .)
    .               reduce using rule 56 (prefixexp -> var .)
    :               reduce using rule 56 (prefixexp -> var .)
    (               reduce using rule 56 (prefixexp -> var .)
    {               reduce using rule 56 (prefixexp -> var .)
    STRING          reduce using rule 56 (prefixexp -> var .)
    ,               reduce using rule 56 (prefixexp -> var .)
    ;               reduce using rule 56 (prefixexp -> var .)
    LOCAL           reduce using rule 56 (prefixexp -> var .)
    FUNCTION        reduce using rule 56 (prefixexp -> var .)
    DO              reduce using rule 56 (prefixexp -> var .)
    WHILE           reduce using rule 56 (prefixexp -> var .)
    REPEAT          reduce using rule 56 (prefixexp -> var .)
    FOR             reduce using rule 56 (prefixexp -> var .)
    IF              reduce using rule 56 (prefixexp -> var .)
    IDENTIFIER      reduce using rule 56 (prefixexp -> var .)
    $end            reduce using rule 56 (prefixexp -> var .)
    END             reduce using rule 56 (prefixexp -> var .)
    UNTIL           reduce using rule 56 (prefixexp -> var .)
    ELSEIF          reduce using rule 56 (prefixexp -> var .)
    ELSE            reduce using rule 56 (prefixexp -> var .)
    CIRCUMFLEX      reduce using rule 56 (prefixexp -> var .)
    TIMES           reduce using rule 56 (prefixexp -> var .)
    DIVIDE          reduce using rule 56 (prefixexp -> var .)
    %               reduce using rule 56 (prefixexp -> var .)
    PLUS            reduce using rule 56 (prefixexp -> var .)
    MINUS           reduce using rule 56 (prefixexp -> var .)
    CONCAT          reduce using rule 56 (prefixexp -> var .)
    LT              reduce using rule 56 (prefixexp -> var .)
    LTE             reduce using rule 56 (prefixexp -> var .)
    GT              reduce using rule 56 (prefixexp -> var .)
    GTE             reduce using rule 56 (prefixexp -> var .)
    NE              reduce using rule 56 (prefixexp -> var .)
    EQUALS          reduce using rule 56 (prefixexp -> var .)
    AND             reduce using rule 56 (prefixexp -> var .)
    OR              reduce using rule 56 (prefixexp -> var .)
    THEN            reduce using rule 56 (prefixexp -> var .)
    )               reduce using rule 56 (prefixexp -> var .)
    }               reduce using rule 56 (prefixexp -> var .)
    RETURN          reduce using rule 56 (prefixexp -> var .)
    BREAK           reduce using rule 56 (prefixexp -> var .)
    ]               reduce using rule 56 (prefixexp -> var .)


state 44

    (57) prefixexp -> functioncall .

    [               reduce using rule 57 (prefixexp -> functioncall .)
    .               reduce using rule 57 (prefixexp -> functioncall .)
    :               reduce using rule 57 (prefixexp -> functioncall .)
    (               reduce using rule 57 (prefixexp -> functioncall .)
    {               reduce using rule 57 (prefixexp -> functioncall .)
    STRING          reduce using rule 57 (prefixexp -> functioncall .)
    ,               reduce using rule 57 (prefixexp -> functioncall .)
    ;               reduce using rule 57 (prefixexp -> functioncall .)
    LOCAL           reduce using rule 57 (prefixexp -> functioncall .)
    FUNCTION        reduce using rule 57 (prefixexp -> functioncall .)
    DO              reduce using rule 57 (prefixexp -> functioncall .)
    WHILE           reduce using rule 57 (prefixexp -> functioncall .)
    REPEAT          reduce using rule 57 (prefixexp -> functioncall .)
    FOR             reduce using rule 57 (prefixexp -> functioncall .)
    IF              reduce using rule 57 (prefixexp -> functioncall .)
    IDENTIFIER      reduce using rule 57 (prefixexp -> functioncall .)
    $end            reduce using rule 57 (prefixexp -> functioncall .)
    END             reduce using rule 57 (prefixexp -> functioncall .)
    UNTIL           reduce using rule 57 (prefixexp -> functioncall .)
    ELSEIF          reduce using rule 57 (prefixexp -> functioncall .)
    ELSE            reduce using rule 57 (prefixexp -> functioncall .)
    CIRCUMFLEX      reduce using rule 57 (prefixexp -> functioncall .)
    TIMES           reduce using rule 57 (prefixexp -> functioncall .)
    DIVIDE          reduce using rule 57 (prefixexp -> functioncall .)
    %               reduce using rule 57 (prefixexp -> functioncall .)
    PLUS            reduce using rule 57 (prefixexp -> functioncall .)
    MINUS           reduce using rule 57 (prefixexp -> functioncall .)
    CONCAT          reduce using rule 57 (prefixexp -> functioncall .)
    LT              reduce using rule 57 (prefixexp -> functioncall .)
    LTE             reduce using rule 57 (prefixexp -> functioncall .)
    GT              reduce using rule 57 (prefixexp -> functioncall .)
    GTE             reduce using rule 57 (prefixexp -> functioncall .)
    NE              reduce using rule 57 (prefixexp -> functioncall .)
    EQUALS          reduce using rule 57 (prefixexp -> functioncall .)
    AND             reduce using rule 57 (prefixexp -> functioncall .)
    OR              reduce using rule 57 (prefixexp -> functioncall .)
    THEN            reduce using rule 57 (prefixexp -> functioncall .)
    )               reduce using rule 57 (prefixexp -> functioncall .)
    }               reduce using rule 57 (prefixexp -> functioncall .)
    RETURN          reduce using rule 57 (prefixexp -> functioncall .)
    BREAK           reduce using rule 57 (prefixexp -> functioncall .)
    ]               reduce using rule 57 (prefixexp -> functioncall .)


state 45

    (72) tableconstructor -> { . fieldlist }
    (73) tableconstructor -> { . }
    (77) fieldlist -> . fieldlist2 optfieldsep
    (78) fieldlist2 -> . field
    (79) fieldlist2 -> . fieldlist2 fieldsep field
    (74) field -> . [ exp ] = exp
    (75) field -> . name = exp
    (76) field -> . exp
    (37) name -> . IDENTIFIER
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp

    }               shift and go to state 91
    [               shift and go to state 94
    IDENTIFIER      shift and go to state 22
    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    fieldlist                      shift and go to state 90
    fieldlist2                     shift and go to state 92
    field                          shift and go to state 93
    exp                            shift and go to state 95
    name                           shift and go to state 96
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57

state 46

    (85) op -> op_1 .
    (86) op_1 -> op_1 . OR op_2

  ! shift/reduce conflict for OR resolved as shift
    ,               reduce using rule 85 (op -> op_1 .)
    ;               reduce using rule 85 (op -> op_1 .)
    LOCAL           reduce using rule 85 (op -> op_1 .)
    FUNCTION        reduce using rule 85 (op -> op_1 .)
    DO              reduce using rule 85 (op -> op_1 .)
    WHILE           reduce using rule 85 (op -> op_1 .)
    REPEAT          reduce using rule 85 (op -> op_1 .)
    FOR             reduce using rule 85 (op -> op_1 .)
    IF              reduce using rule 85 (op -> op_1 .)
    (               reduce using rule 85 (op -> op_1 .)
    IDENTIFIER      reduce using rule 85 (op -> op_1 .)
    $end            reduce using rule 85 (op -> op_1 .)
    END             reduce using rule 85 (op -> op_1 .)
    UNTIL           reduce using rule 85 (op -> op_1 .)
    ELSEIF          reduce using rule 85 (op -> op_1 .)
    ELSE            reduce using rule 85 (op -> op_1 .)
    CIRCUMFLEX      reduce using rule 85 (op -> op_1 .)
    TIMES           reduce using rule 85 (op -> op_1 .)
    DIVIDE          reduce using rule 85 (op -> op_1 .)
    %               reduce using rule 85 (op -> op_1 .)
    PLUS            reduce using rule 85 (op -> op_1 .)
    MINUS           reduce using rule 85 (op -> op_1 .)
    CONCAT          reduce using rule 85 (op -> op_1 .)
    LT              reduce using rule 85 (op -> op_1 .)
    LTE             reduce using rule 85 (op -> op_1 .)
    GT              reduce using rule 85 (op -> op_1 .)
    GTE             reduce using rule 85 (op -> op_1 .)
    NE              reduce using rule 85 (op -> op_1 .)
    EQUALS          reduce using rule 85 (op -> op_1 .)
    AND             reduce using rule 85 (op -> op_1 .)
    THEN            reduce using rule 85 (op -> op_1 .)
    )               reduce using rule 85 (op -> op_1 .)
    }               reduce using rule 85 (op -> op_1 .)
    RETURN          reduce using rule 85 (op -> op_1 .)
    BREAK           reduce using rule 85 (op -> op_1 .)
    ]               reduce using rule 85 (op -> op_1 .)
    OR              shift and go to state 97

  ! OR              [ reduce using rule 85 (op -> op_1 .) ]


state 47

    (87) op_1 -> op_2 .
    (88) op_2 -> op_2 . AND op_3

  ! shift/reduce conflict for AND resolved as shift
    ,               reduce using rule 87 (op_1 -> op_2 .)
    ;               reduce using rule 87 (op_1 -> op_2 .)
    LOCAL           reduce using rule 87 (op_1 -> op_2 .)
    FUNCTION        reduce using rule 87 (op_1 -> op_2 .)
    DO              reduce using rule 87 (op_1 -> op_2 .)
    WHILE           reduce using rule 87 (op_1 -> op_2 .)
    REPEAT          reduce using rule 87 (op_1 -> op_2 .)
    FOR             reduce using rule 87 (op_1 -> op_2 .)
    IF              reduce using rule 87 (op_1 -> op_2 .)
    (               reduce using rule 87 (op_1 -> op_2 .)
    IDENTIFIER      reduce using rule 87 (op_1 -> op_2 .)
    $end            reduce using rule 87 (op_1 -> op_2 .)
    END             reduce using rule 87 (op_1 -> op_2 .)
    UNTIL           reduce using rule 87 (op_1 -> op_2 .)
    ELSEIF          reduce using rule 87 (op_1 -> op_2 .)
    ELSE            reduce using rule 87 (op_1 -> op_2 .)
    CIRCUMFLEX      reduce using rule 87 (op_1 -> op_2 .)
    TIMES           reduce using rule 87 (op_1 -> op_2 .)
    DIVIDE          reduce using rule 87 (op_1 -> op_2 .)
    %               reduce using rule 87 (op_1 -> op_2 .)
    PLUS            reduce using rule 87 (op_1 -> op_2 .)
    MINUS           reduce using rule 87 (op_1 -> op_2 .)
    CONCAT          reduce using rule 87 (op_1 -> op_2 .)
    LT              reduce using rule 87 (op_1 -> op_2 .)
    LTE             reduce using rule 87 (op_1 -> op_2 .)
    GT              reduce using rule 87 (op_1 -> op_2 .)
    GTE             reduce using rule 87 (op_1 -> op_2 .)
    NE              reduce using rule 87 (op_1 -> op_2 .)
    EQUALS          reduce using rule 87 (op_1 -> op_2 .)
    OR              reduce using rule 87 (op_1 -> op_2 .)
    THEN            reduce using rule 87 (op_1 -> op_2 .)
    )               reduce using rule 87 (op_1 -> op_2 .)
    }               reduce using rule 87 (op_1 -> op_2 .)
    RETURN          reduce using rule 87 (op_1 -> op_2 .)
    BREAK           reduce using rule 87 (op_1 -> op_2 .)
    ]               reduce using rule 87 (op_1 -> op_2 .)
    AND             shift and go to state 98

  ! AND             [ reduce using rule 87 (op_1 -> op_2 .) ]


state 48

    (89) op_2 -> op_3 .
    (90) op_3 -> op_3 . LT op_4
    (91) op_3 -> op_3 . LTE op_4
    (92) op_3 -> op_3 . GT op_4
    (93) op_3 -> op_3 . GTE op_4
    (94) op_3 -> op_3 . NE op_4
    (95) op_3 -> op_3 . EQUALS op_4

  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
    ,               reduce using rule 89 (op_2 -> op_3 .)
    ;               reduce using rule 89 (op_2 -> op_3 .)
    LOCAL           reduce using rule 89 (op_2 -> op_3 .)
    FUNCTION        reduce using rule 89 (op_2 -> op_3 .)
    DO              reduce using rule 89 (op_2 -> op_3 .)
    WHILE           reduce using rule 89 (op_2 -> op_3 .)
    REPEAT          reduce using rule 89 (op_2 -> op_3 .)
    FOR             reduce using rule 89 (op_2 -> op_3 .)
    IF              reduce using rule 89 (op_2 -> op_3 .)
    (               reduce using rule 89 (op_2 -> op_3 .)
    IDENTIFIER      reduce using rule 89 (op_2 -> op_3 .)
    $end            reduce using rule 89 (op_2 -> op_3 .)
    END             reduce using rule 89 (op_2 -> op_3 .)
    UNTIL           reduce using rule 89 (op_2 -> op_3 .)
    ELSEIF          reduce using rule 89 (op_2 -> op_3 .)
    ELSE            reduce using rule 89 (op_2 -> op_3 .)
    CIRCUMFLEX      reduce using rule 89 (op_2 -> op_3 .)
    TIMES           reduce using rule 89 (op_2 -> op_3 .)
    DIVIDE          reduce using rule 89 (op_2 -> op_3 .)
    %               reduce using rule 89 (op_2 -> op_3 .)
    PLUS            reduce using rule 89 (op_2 -> op_3 .)
    MINUS           reduce using rule 89 (op_2 -> op_3 .)
    CONCAT          reduce using rule 89 (op_2 -> op_3 .)
    AND             reduce using rule 89 (op_2 -> op_3 .)
    OR              reduce using rule 89 (op_2 -> op_3 .)
    THEN            reduce using rule 89 (op_2 -> op_3 .)
    )               reduce using rule 89 (op_2 -> op_3 .)
    }               reduce using rule 89 (op_2 -> op_3 .)
    RETURN          reduce using rule 89 (op_2 -> op_3 .)
    BREAK           reduce using rule 89 (op_2 -> op_3 .)
    ]               reduce using rule 89 (op_2 -> op_3 .)
    LT              shift and go to state 99
    LTE             shift and go to state 100
    GT              shift and go to state 101
    GTE             shift and go to state 102
    NE              shift and go to state 103
    EQUALS          shift and go to state 104

  ! LT              [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! LTE             [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! GT              [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! GTE             [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! NE              [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! EQUALS          [ reduce using rule 89 (op_2 -> op_3 .) ]


state 49

    (96) op_3 -> op_4 .
    (97) op_4 -> op_4 . CONCAT op_5

  ! shift/reduce conflict for CONCAT resolved as shift
    ,               reduce using rule 96 (op_3 -> op_4 .)
    ;               reduce using rule 96 (op_3 -> op_4 .)
    LOCAL           reduce using rule 96 (op_3 -> op_4 .)
    FUNCTION        reduce using rule 96 (op_3 -> op_4 .)
    DO              reduce using rule 96 (op_3 -> op_4 .)
    WHILE           reduce using rule 96 (op_3 -> op_4 .)
    REPEAT          reduce using rule 96 (op_3 -> op_4 .)
    FOR             reduce using rule 96 (op_3 -> op_4 .)
    IF              reduce using rule 96 (op_3 -> op_4 .)
    (               reduce using rule 96 (op_3 -> op_4 .)
    IDENTIFIER      reduce using rule 96 (op_3 -> op_4 .)
    $end            reduce using rule 96 (op_3 -> op_4 .)
    END             reduce using rule 96 (op_3 -> op_4 .)
    UNTIL           reduce using rule 96 (op_3 -> op_4 .)
    ELSEIF          reduce using rule 96 (op_3 -> op_4 .)
    ELSE            reduce using rule 96 (op_3 -> op_4 .)
    CIRCUMFLEX      reduce using rule 96 (op_3 -> op_4 .)
    TIMES           reduce using rule 96 (op_3 -> op_4 .)
    DIVIDE          reduce using rule 96 (op_3 -> op_4 .)
    %               reduce using rule 96 (op_3 -> op_4 .)
    PLUS            reduce using rule 96 (op_3 -> op_4 .)
    MINUS           reduce using rule 96 (op_3 -> op_4 .)
    LT              reduce using rule 96 (op_3 -> op_4 .)
    LTE             reduce using rule 96 (op_3 -> op_4 .)
    GT              reduce using rule 96 (op_3 -> op_4 .)
    GTE             reduce using rule 96 (op_3 -> op_4 .)
    NE              reduce using rule 96 (op_3 -> op_4 .)
    EQUALS          reduce using rule 96 (op_3 -> op_4 .)
    AND             reduce using rule 96 (op_3 -> op_4 .)
    OR              reduce using rule 96 (op_3 -> op_4 .)
    THEN            reduce using rule 96 (op_3 -> op_4 .)
    )               reduce using rule 96 (op_3 -> op_4 .)
    }               reduce using rule 96 (op_3 -> op_4 .)
    RETURN          reduce using rule 96 (op_3 -> op_4 .)
    BREAK           reduce using rule 96 (op_3 -> op_4 .)
    ]               reduce using rule 96 (op_3 -> op_4 .)
    CONCAT          shift and go to state 105

  ! CONCAT          [ reduce using rule 96 (op_3 -> op_4 .) ]


state 50

    (98) op_4 -> op_5 .
    (99) op_5 -> op_5 . PLUS op_6
    (100) op_5 -> op_5 . MINUS op_6

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    ,               reduce using rule 98 (op_4 -> op_5 .)
    ;               reduce using rule 98 (op_4 -> op_5 .)
    LOCAL           reduce using rule 98 (op_4 -> op_5 .)
    FUNCTION        reduce using rule 98 (op_4 -> op_5 .)
    DO              reduce using rule 98 (op_4 -> op_5 .)
    WHILE           reduce using rule 98 (op_4 -> op_5 .)
    REPEAT          reduce using rule 98 (op_4 -> op_5 .)
    FOR             reduce using rule 98 (op_4 -> op_5 .)
    IF              reduce using rule 98 (op_4 -> op_5 .)
    (               reduce using rule 98 (op_4 -> op_5 .)
    IDENTIFIER      reduce using rule 98 (op_4 -> op_5 .)
    $end            reduce using rule 98 (op_4 -> op_5 .)
    END             reduce using rule 98 (op_4 -> op_5 .)
    UNTIL           reduce using rule 98 (op_4 -> op_5 .)
    ELSEIF          reduce using rule 98 (op_4 -> op_5 .)
    ELSE            reduce using rule 98 (op_4 -> op_5 .)
    CIRCUMFLEX      reduce using rule 98 (op_4 -> op_5 .)
    TIMES           reduce using rule 98 (op_4 -> op_5 .)
    DIVIDE          reduce using rule 98 (op_4 -> op_5 .)
    %               reduce using rule 98 (op_4 -> op_5 .)
    CONCAT          reduce using rule 98 (op_4 -> op_5 .)
    LT              reduce using rule 98 (op_4 -> op_5 .)
    LTE             reduce using rule 98 (op_4 -> op_5 .)
    GT              reduce using rule 98 (op_4 -> op_5 .)
    GTE             reduce using rule 98 (op_4 -> op_5 .)
    NE              reduce using rule 98 (op_4 -> op_5 .)
    EQUALS          reduce using rule 98 (op_4 -> op_5 .)
    AND             reduce using rule 98 (op_4 -> op_5 .)
    OR              reduce using rule 98 (op_4 -> op_5 .)
    THEN            reduce using rule 98 (op_4 -> op_5 .)
    )               reduce using rule 98 (op_4 -> op_5 .)
    }               reduce using rule 98 (op_4 -> op_5 .)
    RETURN          reduce using rule 98 (op_4 -> op_5 .)
    BREAK           reduce using rule 98 (op_4 -> op_5 .)
    ]               reduce using rule 98 (op_4 -> op_5 .)
    PLUS            shift and go to state 106
    MINUS           shift and go to state 107

  ! PLUS            [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! MINUS           [ reduce using rule 98 (op_4 -> op_5 .) ]


state 51

    (101) op_5 -> op_6 .
    (102) op_6 -> op_6 . TIMES op_7
    (103) op_6 -> op_6 . DIVIDE op_7
    (104) op_6 -> op_6 . % op_7

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for % resolved as shift
    ,               reduce using rule 101 (op_5 -> op_6 .)
    ;               reduce using rule 101 (op_5 -> op_6 .)
    LOCAL           reduce using rule 101 (op_5 -> op_6 .)
    FUNCTION        reduce using rule 101 (op_5 -> op_6 .)
    DO              reduce using rule 101 (op_5 -> op_6 .)
    WHILE           reduce using rule 101 (op_5 -> op_6 .)
    REPEAT          reduce using rule 101 (op_5 -> op_6 .)
    FOR             reduce using rule 101 (op_5 -> op_6 .)
    IF              reduce using rule 101 (op_5 -> op_6 .)
    (               reduce using rule 101 (op_5 -> op_6 .)
    IDENTIFIER      reduce using rule 101 (op_5 -> op_6 .)
    $end            reduce using rule 101 (op_5 -> op_6 .)
    END             reduce using rule 101 (op_5 -> op_6 .)
    UNTIL           reduce using rule 101 (op_5 -> op_6 .)
    ELSEIF          reduce using rule 101 (op_5 -> op_6 .)
    ELSE            reduce using rule 101 (op_5 -> op_6 .)
    CIRCUMFLEX      reduce using rule 101 (op_5 -> op_6 .)
    PLUS            reduce using rule 101 (op_5 -> op_6 .)
    MINUS           reduce using rule 101 (op_5 -> op_6 .)
    CONCAT          reduce using rule 101 (op_5 -> op_6 .)
    LT              reduce using rule 101 (op_5 -> op_6 .)
    LTE             reduce using rule 101 (op_5 -> op_6 .)
    GT              reduce using rule 101 (op_5 -> op_6 .)
    GTE             reduce using rule 101 (op_5 -> op_6 .)
    NE              reduce using rule 101 (op_5 -> op_6 .)
    EQUALS          reduce using rule 101 (op_5 -> op_6 .)
    AND             reduce using rule 101 (op_5 -> op_6 .)
    OR              reduce using rule 101 (op_5 -> op_6 .)
    THEN            reduce using rule 101 (op_5 -> op_6 .)
    )               reduce using rule 101 (op_5 -> op_6 .)
    }               reduce using rule 101 (op_5 -> op_6 .)
    RETURN          reduce using rule 101 (op_5 -> op_6 .)
    BREAK           reduce using rule 101 (op_5 -> op_6 .)
    ]               reduce using rule 101 (op_5 -> op_6 .)
    TIMES           shift and go to state 108
    DIVIDE          shift and go to state 109
    %               shift and go to state 110

  ! TIMES           [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! DIVIDE          [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! %               [ reduce using rule 101 (op_5 -> op_6 .) ]


state 52

    (108) op_7 -> MINUS . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8

    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    op_8                           shift and go to state 111
    op_9                           shift and go to state 57
    exp                            shift and go to state 112
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53

state 53

    (105) op_6 -> op_7 .

    ,               reduce using rule 105 (op_6 -> op_7 .)
    ;               reduce using rule 105 (op_6 -> op_7 .)
    LOCAL           reduce using rule 105 (op_6 -> op_7 .)
    FUNCTION        reduce using rule 105 (op_6 -> op_7 .)
    DO              reduce using rule 105 (op_6 -> op_7 .)
    WHILE           reduce using rule 105 (op_6 -> op_7 .)
    REPEAT          reduce using rule 105 (op_6 -> op_7 .)
    FOR             reduce using rule 105 (op_6 -> op_7 .)
    IF              reduce using rule 105 (op_6 -> op_7 .)
    (               reduce using rule 105 (op_6 -> op_7 .)
    IDENTIFIER      reduce using rule 105 (op_6 -> op_7 .)
    $end            reduce using rule 105 (op_6 -> op_7 .)
    END             reduce using rule 105 (op_6 -> op_7 .)
    UNTIL           reduce using rule 105 (op_6 -> op_7 .)
    ELSEIF          reduce using rule 105 (op_6 -> op_7 .)
    ELSE            reduce using rule 105 (op_6 -> op_7 .)
    CIRCUMFLEX      reduce using rule 105 (op_6 -> op_7 .)
    TIMES           reduce using rule 105 (op_6 -> op_7 .)
    DIVIDE          reduce using rule 105 (op_6 -> op_7 .)
    %               reduce using rule 105 (op_6 -> op_7 .)
    PLUS            reduce using rule 105 (op_6 -> op_7 .)
    MINUS           reduce using rule 105 (op_6 -> op_7 .)
    CONCAT          reduce using rule 105 (op_6 -> op_7 .)
    LT              reduce using rule 105 (op_6 -> op_7 .)
    LTE             reduce using rule 105 (op_6 -> op_7 .)
    GT              reduce using rule 105 (op_6 -> op_7 .)
    GTE             reduce using rule 105 (op_6 -> op_7 .)
    NE              reduce using rule 105 (op_6 -> op_7 .)
    EQUALS          reduce using rule 105 (op_6 -> op_7 .)
    AND             reduce using rule 105 (op_6 -> op_7 .)
    OR              reduce using rule 105 (op_6 -> op_7 .)
    THEN            reduce using rule 105 (op_6 -> op_7 .)
    )               reduce using rule 105 (op_6 -> op_7 .)
    }               reduce using rule 105 (op_6 -> op_7 .)
    RETURN          reduce using rule 105 (op_6 -> op_7 .)
    BREAK           reduce using rule 105 (op_6 -> op_7 .)
    ]               reduce using rule 105 (op_6 -> op_7 .)


state 54

    (106) op_7 -> NOT . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8

    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    op_8                           shift and go to state 113
    op_9                           shift and go to state 57
    exp                            shift and go to state 112
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53

state 55

    (109) op_7 -> op_8 .
    (110) op_8 -> op_8 . CIRCUMFLEX op_9

  ! shift/reduce conflict for CIRCUMFLEX resolved as shift
    ,               reduce using rule 109 (op_7 -> op_8 .)
    ;               reduce using rule 109 (op_7 -> op_8 .)
    LOCAL           reduce using rule 109 (op_7 -> op_8 .)
    FUNCTION        reduce using rule 109 (op_7 -> op_8 .)
    DO              reduce using rule 109 (op_7 -> op_8 .)
    WHILE           reduce using rule 109 (op_7 -> op_8 .)
    REPEAT          reduce using rule 109 (op_7 -> op_8 .)
    FOR             reduce using rule 109 (op_7 -> op_8 .)
    IF              reduce using rule 109 (op_7 -> op_8 .)
    (               reduce using rule 109 (op_7 -> op_8 .)
    IDENTIFIER      reduce using rule 109 (op_7 -> op_8 .)
    $end            reduce using rule 109 (op_7 -> op_8 .)
    END             reduce using rule 109 (op_7 -> op_8 .)
    UNTIL           reduce using rule 109 (op_7 -> op_8 .)
    ELSEIF          reduce using rule 109 (op_7 -> op_8 .)
    ELSE            reduce using rule 109 (op_7 -> op_8 .)
    TIMES           reduce using rule 109 (op_7 -> op_8 .)
    DIVIDE          reduce using rule 109 (op_7 -> op_8 .)
    %               reduce using rule 109 (op_7 -> op_8 .)
    PLUS            reduce using rule 109 (op_7 -> op_8 .)
    MINUS           reduce using rule 109 (op_7 -> op_8 .)
    CONCAT          reduce using rule 109 (op_7 -> op_8 .)
    LT              reduce using rule 109 (op_7 -> op_8 .)
    LTE             reduce using rule 109 (op_7 -> op_8 .)
    GT              reduce using rule 109 (op_7 -> op_8 .)
    GTE             reduce using rule 109 (op_7 -> op_8 .)
    NE              reduce using rule 109 (op_7 -> op_8 .)
    EQUALS          reduce using rule 109 (op_7 -> op_8 .)
    AND             reduce using rule 109 (op_7 -> op_8 .)
    OR              reduce using rule 109 (op_7 -> op_8 .)
    THEN            reduce using rule 109 (op_7 -> op_8 .)
    )               reduce using rule 109 (op_7 -> op_8 .)
    }               reduce using rule 109 (op_7 -> op_8 .)
    RETURN          reduce using rule 109 (op_7 -> op_8 .)
    BREAK           reduce using rule 109 (op_7 -> op_8 .)
    ]               reduce using rule 109 (op_7 -> op_8 .)
    CIRCUMFLEX      shift and go to state 114

  ! CIRCUMFLEX      [ reduce using rule 109 (op_7 -> op_8 .) ]


state 56

    (107) op_7 -> HASH . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8

    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    op_8                           shift and go to state 115
    op_9                           shift and go to state 57
    exp                            shift and go to state 112
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53

state 57

    (111) op_8 -> op_9 .

    ,               reduce using rule 111 (op_8 -> op_9 .)
    ;               reduce using rule 111 (op_8 -> op_9 .)
    LOCAL           reduce using rule 111 (op_8 -> op_9 .)
    FUNCTION        reduce using rule 111 (op_8 -> op_9 .)
    DO              reduce using rule 111 (op_8 -> op_9 .)
    WHILE           reduce using rule 111 (op_8 -> op_9 .)
    REPEAT          reduce using rule 111 (op_8 -> op_9 .)
    FOR             reduce using rule 111 (op_8 -> op_9 .)
    IF              reduce using rule 111 (op_8 -> op_9 .)
    (               reduce using rule 111 (op_8 -> op_9 .)
    IDENTIFIER      reduce using rule 111 (op_8 -> op_9 .)
    $end            reduce using rule 111 (op_8 -> op_9 .)
    END             reduce using rule 111 (op_8 -> op_9 .)
    UNTIL           reduce using rule 111 (op_8 -> op_9 .)
    ELSEIF          reduce using rule 111 (op_8 -> op_9 .)
    ELSE            reduce using rule 111 (op_8 -> op_9 .)
    CIRCUMFLEX      reduce using rule 111 (op_8 -> op_9 .)
    TIMES           reduce using rule 111 (op_8 -> op_9 .)
    DIVIDE          reduce using rule 111 (op_8 -> op_9 .)
    %               reduce using rule 111 (op_8 -> op_9 .)
    PLUS            reduce using rule 111 (op_8 -> op_9 .)
    MINUS           reduce using rule 111 (op_8 -> op_9 .)
    CONCAT          reduce using rule 111 (op_8 -> op_9 .)
    LT              reduce using rule 111 (op_8 -> op_9 .)
    LTE             reduce using rule 111 (op_8 -> op_9 .)
    GT              reduce using rule 111 (op_8 -> op_9 .)
    GTE             reduce using rule 111 (op_8 -> op_9 .)
    NE              reduce using rule 111 (op_8 -> op_9 .)
    EQUALS          reduce using rule 111 (op_8 -> op_9 .)
    AND             reduce using rule 111 (op_8 -> op_9 .)
    OR              reduce using rule 111 (op_8 -> op_9 .)
    THEN            reduce using rule 111 (op_8 -> op_9 .)
    )               reduce using rule 111 (op_8 -> op_9 .)
    }               reduce using rule 111 (op_8 -> op_9 .)
    RETURN          reduce using rule 111 (op_8 -> op_9 .)
    BREAK           reduce using rule 111 (op_8 -> op_9 .)
    ]               reduce using rule 111 (op_8 -> op_9 .)


state 58

    (11) laststat -> BREAK optsemi .

    LOCAL           reduce using rule 11 (laststat -> BREAK optsemi .)
    FUNCTION        reduce using rule 11 (laststat -> BREAK optsemi .)
    DO              reduce using rule 11 (laststat -> BREAK optsemi .)
    WHILE           reduce using rule 11 (laststat -> BREAK optsemi .)
    REPEAT          reduce using rule 11 (laststat -> BREAK optsemi .)
    FOR             reduce using rule 11 (laststat -> BREAK optsemi .)
    IF              reduce using rule 11 (laststat -> BREAK optsemi .)
    (               reduce using rule 11 (laststat -> BREAK optsemi .)
    IDENTIFIER      reduce using rule 11 (laststat -> BREAK optsemi .)
    $end            reduce using rule 11 (laststat -> BREAK optsemi .)
    END             reduce using rule 11 (laststat -> BREAK optsemi .)
    UNTIL           reduce using rule 11 (laststat -> BREAK optsemi .)
    ELSEIF          reduce using rule 11 (laststat -> BREAK optsemi .)
    ELSE            reduce using rule 11 (laststat -> BREAK optsemi .)


state 59

    (12) stat -> varlist = . explist
    (54) explist -> . exp
    (55) explist -> . explist , exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp

    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    explist                        shift and go to state 116
    exp                            shift and go to state 30
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57

state 60

    (36) varlist -> varlist , . var
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (37) name -> . IDENTIFIER
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args

    IDENTIFIER      shift and go to state 22
    (               shift and go to state 21

    var                            shift and go to state 117
    name                           shift and go to state 11
    prefixexp                      shift and go to state 118
    functioncall                   shift and go to state 44

state 61

    (13) stat -> LOCAL namelist . = explist
    (14) stat -> LOCAL namelist .
    (43) namelist -> namelist . , name

    =               shift and go to state 119
    ;               reduce using rule 14 (stat -> LOCAL namelist .)
    RETURN          reduce using rule 14 (stat -> LOCAL namelist .)
    BREAK           reduce using rule 14 (stat -> LOCAL namelist .)
    LOCAL           reduce using rule 14 (stat -> LOCAL namelist .)
    FUNCTION        reduce using rule 14 (stat -> LOCAL namelist .)
    DO              reduce using rule 14 (stat -> LOCAL namelist .)
    WHILE           reduce using rule 14 (stat -> LOCAL namelist .)
    REPEAT          reduce using rule 14 (stat -> LOCAL namelist .)
    FOR             reduce using rule 14 (stat -> LOCAL namelist .)
    IF              reduce using rule 14 (stat -> LOCAL namelist .)
    (               reduce using rule 14 (stat -> LOCAL namelist .)
    IDENTIFIER      reduce using rule 14 (stat -> LOCAL namelist .)
    $end            reduce using rule 14 (stat -> LOCAL namelist .)
    END             reduce using rule 14 (stat -> LOCAL namelist .)
    UNTIL           reduce using rule 14 (stat -> LOCAL namelist .)
    ELSEIF          reduce using rule 14 (stat -> LOCAL namelist .)
    ELSE            reduce using rule 14 (stat -> LOCAL namelist .)
    ,               shift and go to state 120


state 62

    (16) stat -> LOCAL FUNCTION . name funcbody
    (37) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 22

    name                           shift and go to state 121

state 63

    (42) namelist -> name .

    =               reduce using rule 42 (namelist -> name .)
    ,               reduce using rule 42 (namelist -> name .)
    ;               reduce using rule 42 (namelist -> name .)
    RETURN          reduce using rule 42 (namelist -> name .)
    BREAK           reduce using rule 42 (namelist -> name .)
    LOCAL           reduce using rule 42 (namelist -> name .)
    FUNCTION        reduce using rule 42 (namelist -> name .)
    DO              reduce using rule 42 (namelist -> name .)
    WHILE           reduce using rule 42 (namelist -> name .)
    REPEAT          reduce using rule 42 (namelist -> name .)
    FOR             reduce using rule 42 (namelist -> name .)
    IF              reduce using rule 42 (namelist -> name .)
    (               reduce using rule 42 (namelist -> name .)
    IDENTIFIER      reduce using rule 42 (namelist -> name .)
    $end            reduce using rule 42 (namelist -> name .)
    END             reduce using rule 42 (namelist -> name .)
    UNTIL           reduce using rule 42 (namelist -> name .)
    ELSEIF          reduce using rule 42 (namelist -> name .)
    ELSE            reduce using rule 42 (namelist -> name .)
    )               reduce using rule 42 (namelist -> name .)


state 64

    (15) stat -> FUNCTION funcname . funcbody
    (63) funcbody -> . ( parlist ) block END
    (64) funcbody -> . ( ) block END

    (               shift and go to state 89

    funcbody                       shift and go to state 122

state 65

    (38) funcname -> funcname2 .
    (39) funcname -> funcname2 . : name
    (41) funcname2 -> funcname2 . . name

    (               reduce using rule 38 (funcname -> funcname2 .)
    :               shift and go to state 123
    .               shift and go to state 124


state 66

    (40) funcname2 -> name .

    :               reduce using rule 40 (funcname2 -> name .)
    .               reduce using rule 40 (funcname2 -> name .)
    (               reduce using rule 40 (funcname2 -> name .)


state 67

    (18) stat -> DO block . END

    END             shift and go to state 125


state 68

    (19) stat -> WHILE exp . DO block END
    (112) op_9 -> exp .

  ! shift/reduce conflict for DO resolved as shift
    DO              shift and go to state 126
    CIRCUMFLEX      reduce using rule 112 (op_9 -> exp .)
    TIMES           reduce using rule 112 (op_9 -> exp .)
    DIVIDE          reduce using rule 112 (op_9 -> exp .)
    %               reduce using rule 112 (op_9 -> exp .)
    PLUS            reduce using rule 112 (op_9 -> exp .)
    MINUS           reduce using rule 112 (op_9 -> exp .)
    CONCAT          reduce using rule 112 (op_9 -> exp .)
    LT              reduce using rule 112 (op_9 -> exp .)
    LTE             reduce using rule 112 (op_9 -> exp .)
    GT              reduce using rule 112 (op_9 -> exp .)
    GTE             reduce using rule 112 (op_9 -> exp .)
    NE              reduce using rule 112 (op_9 -> exp .)
    EQUALS          reduce using rule 112 (op_9 -> exp .)
    AND             reduce using rule 112 (op_9 -> exp .)
    OR              reduce using rule 112 (op_9 -> exp .)

  ! DO              [ reduce using rule 112 (op_9 -> exp .) ]


state 69

    (20) stat -> REPEAT block . UNTIL exp

    UNTIL           shift and go to state 127


state 70

    (21) stat -> if elseiflist . else END
    (27) elseiflist -> elseiflist . elseif
    (30) else -> . ELSE block
    (31) else -> . empty
    (29) elseif -> . ELSEIF exp THEN block
    (113) empty -> .

    ELSE            shift and go to state 130
    ELSEIF          shift and go to state 73
    END             reduce using rule 113 (empty -> .)

    else                           shift and go to state 128
    elseif                         shift and go to state 129
    empty                          shift and go to state 131

state 71

    (26) elseiflist -> elseif .

    ELSE            reduce using rule 26 (elseiflist -> elseif .)
    ELSEIF          reduce using rule 26 (elseiflist -> elseif .)
    END             reduce using rule 26 (elseiflist -> elseif .)


state 72

    (28) elseiflist -> empty .

    ELSE            reduce using rule 28 (elseiflist -> empty .)
    ELSEIF          reduce using rule 28 (elseiflist -> empty .)
    END             reduce using rule 28 (elseiflist -> empty .)


state 73

    (29) elseif -> ELSEIF . exp THEN block
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp

    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    exp                            shift and go to state 132
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57

state 74

    (22) stat -> FOR name . = exp , exp DO block END
    (23) stat -> FOR name . = exp , exp , exp DO block END
    (42) namelist -> name .

    =               shift and go to state 133
    IN              reduce using rule 42 (namelist -> name .)
    ,               reduce using rule 42 (namelist -> name .)


state 75

    (24) stat -> FOR namelist . IN explist DO block END
    (43) namelist -> namelist . , name

    IN              shift and go to state 134
    ,               shift and go to state 120


state 76

    (60) functioncall -> prefixexp args .

    ;               reduce using rule 60 (functioncall -> prefixexp args .)
    RETURN          reduce using rule 60 (functioncall -> prefixexp args .)
    BREAK           reduce using rule 60 (functioncall -> prefixexp args .)
    LOCAL           reduce using rule 60 (functioncall -> prefixexp args .)
    FUNCTION        reduce using rule 60 (functioncall -> prefixexp args .)
    DO              reduce using rule 60 (functioncall -> prefixexp args .)
    WHILE           reduce using rule 60 (functioncall -> prefixexp args .)
    REPEAT          reduce using rule 60 (functioncall -> prefixexp args .)
    FOR             reduce using rule 60 (functioncall -> prefixexp args .)
    IF              reduce using rule 60 (functioncall -> prefixexp args .)
    (               reduce using rule 60 (functioncall -> prefixexp args .)
    IDENTIFIER      reduce using rule 60 (functioncall -> prefixexp args .)
    $end            reduce using rule 60 (functioncall -> prefixexp args .)
    :               reduce using rule 60 (functioncall -> prefixexp args .)
    [               reduce using rule 60 (functioncall -> prefixexp args .)
    .               reduce using rule 60 (functioncall -> prefixexp args .)
    {               reduce using rule 60 (functioncall -> prefixexp args .)
    STRING          reduce using rule 60 (functioncall -> prefixexp args .)
    END             reduce using rule 60 (functioncall -> prefixexp args .)
    UNTIL           reduce using rule 60 (functioncall -> prefixexp args .)
    ELSEIF          reduce using rule 60 (functioncall -> prefixexp args .)
    ELSE            reduce using rule 60 (functioncall -> prefixexp args .)
    ,               reduce using rule 60 (functioncall -> prefixexp args .)
    CIRCUMFLEX      reduce using rule 60 (functioncall -> prefixexp args .)
    TIMES           reduce using rule 60 (functioncall -> prefixexp args .)
    DIVIDE          reduce using rule 60 (functioncall -> prefixexp args .)
    %               reduce using rule 60 (functioncall -> prefixexp args .)
    PLUS            reduce using rule 60 (functioncall -> prefixexp args .)
    MINUS           reduce using rule 60 (functioncall -> prefixexp args .)
    CONCAT          reduce using rule 60 (functioncall -> prefixexp args .)
    LT              reduce using rule 60 (functioncall -> prefixexp args .)
    LTE             reduce using rule 60 (functioncall -> prefixexp args .)
    GT              reduce using rule 60 (functioncall -> prefixexp args .)
    GTE             reduce using rule 60 (functioncall -> prefixexp args .)
    NE              reduce using rule 60 (functioncall -> prefixexp args .)
    EQUALS          reduce using rule 60 (functioncall -> prefixexp args .)
    AND             reduce using rule 60 (functioncall -> prefixexp args .)
    OR              reduce using rule 60 (functioncall -> prefixexp args .)
    THEN            reduce using rule 60 (functioncall -> prefixexp args .)
    )               reduce using rule 60 (functioncall -> prefixexp args .)
    }               reduce using rule 60 (functioncall -> prefixexp args .)
    ]               reduce using rule 60 (functioncall -> prefixexp args .)


state 77

    (61) functioncall -> prefixexp : . name args
    (37) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 22

    name                           shift and go to state 135

state 78

    (33) var -> prefixexp [ . exp ]
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp

    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    prefixexp                      shift and go to state 38
    exp                            shift and go to state 136
    string                         shift and go to state 35
    function                       shift and go to state 37
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57

state 79

    (34) var -> prefixexp . . name
    (37) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 22

    name                           shift and go to state 137

state 80

    (68) args -> ( . )
    (69) args -> ( . explist )
    (54) explist -> . exp
    (55) explist -> . explist , exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp

    )               shift and go to state 138
    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    explist                        shift and go to state 139
    exp                            shift and go to state 30
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57

state 81

    (70) args -> tableconstructor .

    ;               reduce using rule 70 (args -> tableconstructor .)
    RETURN          reduce using rule 70 (args -> tableconstructor .)
    BREAK           reduce using rule 70 (args -> tableconstructor .)
    LOCAL           reduce using rule 70 (args -> tableconstructor .)
    FUNCTION        reduce using rule 70 (args -> tableconstructor .)
    DO              reduce using rule 70 (args -> tableconstructor .)
    WHILE           reduce using rule 70 (args -> tableconstructor .)
    REPEAT          reduce using rule 70 (args -> tableconstructor .)
    FOR             reduce using rule 70 (args -> tableconstructor .)
    IF              reduce using rule 70 (args -> tableconstructor .)
    (               reduce using rule 70 (args -> tableconstructor .)
    IDENTIFIER      reduce using rule 70 (args -> tableconstructor .)
    $end            reduce using rule 70 (args -> tableconstructor .)
    :               reduce using rule 70 (args -> tableconstructor .)
    [               reduce using rule 70 (args -> tableconstructor .)
    .               reduce using rule 70 (args -> tableconstructor .)
    {               reduce using rule 70 (args -> tableconstructor .)
    STRING          reduce using rule 70 (args -> tableconstructor .)
    END             reduce using rule 70 (args -> tableconstructor .)
    UNTIL           reduce using rule 70 (args -> tableconstructor .)
    ELSEIF          reduce using rule 70 (args -> tableconstructor .)
    ELSE            reduce using rule 70 (args -> tableconstructor .)
    ,               reduce using rule 70 (args -> tableconstructor .)
    CIRCUMFLEX      reduce using rule 70 (args -> tableconstructor .)
    TIMES           reduce using rule 70 (args -> tableconstructor .)
    DIVIDE          reduce using rule 70 (args -> tableconstructor .)
    %               reduce using rule 70 (args -> tableconstructor .)
    PLUS            reduce using rule 70 (args -> tableconstructor .)
    MINUS           reduce using rule 70 (args -> tableconstructor .)
    CONCAT          reduce using rule 70 (args -> tableconstructor .)
    LT              reduce using rule 70 (args -> tableconstructor .)
    LTE             reduce using rule 70 (args -> tableconstructor .)
    GT              reduce using rule 70 (args -> tableconstructor .)
    GTE             reduce using rule 70 (args -> tableconstructor .)
    NE              reduce using rule 70 (args -> tableconstructor .)
    EQUALS          reduce using rule 70 (args -> tableconstructor .)
    AND             reduce using rule 70 (args -> tableconstructor .)
    OR              reduce using rule 70 (args -> tableconstructor .)
    THEN            reduce using rule 70 (args -> tableconstructor .)
    )               reduce using rule 70 (args -> tableconstructor .)
    }               reduce using rule 70 (args -> tableconstructor .)
    ]               reduce using rule 70 (args -> tableconstructor .)


state 82

    (71) args -> string .

    ;               reduce using rule 71 (args -> string .)
    RETURN          reduce using rule 71 (args -> string .)
    BREAK           reduce using rule 71 (args -> string .)
    LOCAL           reduce using rule 71 (args -> string .)
    FUNCTION        reduce using rule 71 (args -> string .)
    DO              reduce using rule 71 (args -> string .)
    WHILE           reduce using rule 71 (args -> string .)
    REPEAT          reduce using rule 71 (args -> string .)
    FOR             reduce using rule 71 (args -> string .)
    IF              reduce using rule 71 (args -> string .)
    (               reduce using rule 71 (args -> string .)
    IDENTIFIER      reduce using rule 71 (args -> string .)
    $end            reduce using rule 71 (args -> string .)
    :               reduce using rule 71 (args -> string .)
    [               reduce using rule 71 (args -> string .)
    .               reduce using rule 71 (args -> string .)
    {               reduce using rule 71 (args -> string .)
    STRING          reduce using rule 71 (args -> string .)
    END             reduce using rule 71 (args -> string .)
    UNTIL           reduce using rule 71 (args -> string .)
    ELSEIF          reduce using rule 71 (args -> string .)
    ELSE            reduce using rule 71 (args -> string .)
    ,               reduce using rule 71 (args -> string .)
    CIRCUMFLEX      reduce using rule 71 (args -> string .)
    TIMES           reduce using rule 71 (args -> string .)
    DIVIDE          reduce using rule 71 (args -> string .)
    %               reduce using rule 71 (args -> string .)
    PLUS            reduce using rule 71 (args -> string .)
    MINUS           reduce using rule 71 (args -> string .)
    CONCAT          reduce using rule 71 (args -> string .)
    LT              reduce using rule 71 (args -> string .)
    LTE             reduce using rule 71 (args -> string .)
    GT              reduce using rule 71 (args -> string .)
    GTE             reduce using rule 71 (args -> string .)
    NE              reduce using rule 71 (args -> string .)
    EQUALS          reduce using rule 71 (args -> string .)
    AND             reduce using rule 71 (args -> string .)
    OR              reduce using rule 71 (args -> string .)
    THEN            reduce using rule 71 (args -> string .)
    )               reduce using rule 71 (args -> string .)
    }               reduce using rule 71 (args -> string .)
    ]               reduce using rule 71 (args -> string .)


state 83

    (25) if -> IF exp . THEN block
    (112) op_9 -> exp .

  ! shift/reduce conflict for THEN resolved as shift
    THEN            shift and go to state 140
    CIRCUMFLEX      reduce using rule 112 (op_9 -> exp .)
    TIMES           reduce using rule 112 (op_9 -> exp .)
    DIVIDE          reduce using rule 112 (op_9 -> exp .)
    %               reduce using rule 112 (op_9 -> exp .)
    PLUS            reduce using rule 112 (op_9 -> exp .)
    MINUS           reduce using rule 112 (op_9 -> exp .)
    CONCAT          reduce using rule 112 (op_9 -> exp .)
    LT              reduce using rule 112 (op_9 -> exp .)
    LTE             reduce using rule 112 (op_9 -> exp .)
    GT              reduce using rule 112 (op_9 -> exp .)
    GTE             reduce using rule 112 (op_9 -> exp .)
    NE              reduce using rule 112 (op_9 -> exp .)
    EQUALS          reduce using rule 112 (op_9 -> exp .)
    AND             reduce using rule 112 (op_9 -> exp .)
    OR              reduce using rule 112 (op_9 -> exp .)

  ! THEN            [ reduce using rule 112 (op_9 -> exp .) ]


state 84

    (58) prefixexp -> ( exp . )
    (112) op_9 -> exp .

  ! shift/reduce conflict for ) resolved as shift
    )               shift and go to state 141
    CIRCUMFLEX      reduce using rule 112 (op_9 -> exp .)
    TIMES           reduce using rule 112 (op_9 -> exp .)
    DIVIDE          reduce using rule 112 (op_9 -> exp .)
    %               reduce using rule 112 (op_9 -> exp .)
    PLUS            reduce using rule 112 (op_9 -> exp .)
    MINUS           reduce using rule 112 (op_9 -> exp .)
    CONCAT          reduce using rule 112 (op_9 -> exp .)
    LT              reduce using rule 112 (op_9 -> exp .)
    LTE             reduce using rule 112 (op_9 -> exp .)
    GT              reduce using rule 112 (op_9 -> exp .)
    GTE             reduce using rule 112 (op_9 -> exp .)
    NE              reduce using rule 112 (op_9 -> exp .)
    EQUALS          reduce using rule 112 (op_9 -> exp .)
    AND             reduce using rule 112 (op_9 -> exp .)
    OR              reduce using rule 112 (op_9 -> exp .)

  ! )               [ reduce using rule 112 (op_9 -> exp .) ]


state 85

    (6) chunk2 -> chunk stat optsemi .

    RETURN          reduce using rule 6 (chunk2 -> chunk stat optsemi .)
    BREAK           reduce using rule 6 (chunk2 -> chunk stat optsemi .)
    LOCAL           reduce using rule 6 (chunk2 -> chunk stat optsemi .)
    FUNCTION        reduce using rule 6 (chunk2 -> chunk stat optsemi .)
    DO              reduce using rule 6 (chunk2 -> chunk stat optsemi .)
    WHILE           reduce using rule 6 (chunk2 -> chunk stat optsemi .)
    REPEAT          reduce using rule 6 (chunk2 -> chunk stat optsemi .)
    FOR             reduce using rule 6 (chunk2 -> chunk stat optsemi .)
    IF              reduce using rule 6 (chunk2 -> chunk stat optsemi .)
    (               reduce using rule 6 (chunk2 -> chunk stat optsemi .)
    IDENTIFIER      reduce using rule 6 (chunk2 -> chunk stat optsemi .)
    $end            reduce using rule 6 (chunk2 -> chunk stat optsemi .)
    END             reduce using rule 6 (chunk2 -> chunk stat optsemi .)
    UNTIL           reduce using rule 6 (chunk2 -> chunk stat optsemi .)
    ELSEIF          reduce using rule 6 (chunk2 -> chunk stat optsemi .)
    ELSE            reduce using rule 6 (chunk2 -> chunk stat optsemi .)


state 86

    (9) laststat -> RETURN explist optsemi .

    LOCAL           reduce using rule 9 (laststat -> RETURN explist optsemi .)
    FUNCTION        reduce using rule 9 (laststat -> RETURN explist optsemi .)
    DO              reduce using rule 9 (laststat -> RETURN explist optsemi .)
    WHILE           reduce using rule 9 (laststat -> RETURN explist optsemi .)
    REPEAT          reduce using rule 9 (laststat -> RETURN explist optsemi .)
    FOR             reduce using rule 9 (laststat -> RETURN explist optsemi .)
    IF              reduce using rule 9 (laststat -> RETURN explist optsemi .)
    (               reduce using rule 9 (laststat -> RETURN explist optsemi .)
    IDENTIFIER      reduce using rule 9 (laststat -> RETURN explist optsemi .)
    $end            reduce using rule 9 (laststat -> RETURN explist optsemi .)
    END             reduce using rule 9 (laststat -> RETURN explist optsemi .)
    UNTIL           reduce using rule 9 (laststat -> RETURN explist optsemi .)
    ELSEIF          reduce using rule 9 (laststat -> RETURN explist optsemi .)
    ELSE            reduce using rule 9 (laststat -> RETURN explist optsemi .)


state 87

    (55) explist -> explist , . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp

    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    exp                            shift and go to state 142
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57

state 88

    (59) function -> FUNCTION funcbody .

    ,               reduce using rule 59 (function -> FUNCTION funcbody .)
    ;               reduce using rule 59 (function -> FUNCTION funcbody .)
    LOCAL           reduce using rule 59 (function -> FUNCTION funcbody .)
    FUNCTION        reduce using rule 59 (function -> FUNCTION funcbody .)
    DO              reduce using rule 59 (function -> FUNCTION funcbody .)
    WHILE           reduce using rule 59 (function -> FUNCTION funcbody .)
    REPEAT          reduce using rule 59 (function -> FUNCTION funcbody .)
    FOR             reduce using rule 59 (function -> FUNCTION funcbody .)
    IF              reduce using rule 59 (function -> FUNCTION funcbody .)
    (               reduce using rule 59 (function -> FUNCTION funcbody .)
    IDENTIFIER      reduce using rule 59 (function -> FUNCTION funcbody .)
    $end            reduce using rule 59 (function -> FUNCTION funcbody .)
    END             reduce using rule 59 (function -> FUNCTION funcbody .)
    UNTIL           reduce using rule 59 (function -> FUNCTION funcbody .)
    ELSEIF          reduce using rule 59 (function -> FUNCTION funcbody .)
    ELSE            reduce using rule 59 (function -> FUNCTION funcbody .)
    CIRCUMFLEX      reduce using rule 59 (function -> FUNCTION funcbody .)
    TIMES           reduce using rule 59 (function -> FUNCTION funcbody .)
    DIVIDE          reduce using rule 59 (function -> FUNCTION funcbody .)
    %               reduce using rule 59 (function -> FUNCTION funcbody .)
    PLUS            reduce using rule 59 (function -> FUNCTION funcbody .)
    MINUS           reduce using rule 59 (function -> FUNCTION funcbody .)
    CONCAT          reduce using rule 59 (function -> FUNCTION funcbody .)
    LT              reduce using rule 59 (function -> FUNCTION funcbody .)
    LTE             reduce using rule 59 (function -> FUNCTION funcbody .)
    GT              reduce using rule 59 (function -> FUNCTION funcbody .)
    GTE             reduce using rule 59 (function -> FUNCTION funcbody .)
    NE              reduce using rule 59 (function -> FUNCTION funcbody .)
    EQUALS          reduce using rule 59 (function -> FUNCTION funcbody .)
    AND             reduce using rule 59 (function -> FUNCTION funcbody .)
    OR              reduce using rule 59 (function -> FUNCTION funcbody .)
    THEN            reduce using rule 59 (function -> FUNCTION funcbody .)
    )               reduce using rule 59 (function -> FUNCTION funcbody .)
    }               reduce using rule 59 (function -> FUNCTION funcbody .)
    RETURN          reduce using rule 59 (function -> FUNCTION funcbody .)
    BREAK           reduce using rule 59 (function -> FUNCTION funcbody .)
    ]               reduce using rule 59 (function -> FUNCTION funcbody .)


state 89

    (63) funcbody -> ( . parlist ) block END
    (64) funcbody -> ( . ) block END
    (65) parlist -> . namelist
    (66) parlist -> . namelist , TDOT
    (67) parlist -> . TDOT
    (42) namelist -> . name
    (43) namelist -> . namelist , name
    (37) name -> . IDENTIFIER

    )               shift and go to state 144
    TDOT            shift and go to state 146
    IDENTIFIER      shift and go to state 22

    parlist                        shift and go to state 143
    namelist                       shift and go to state 145
    name                           shift and go to state 63

state 90

    (72) tableconstructor -> { fieldlist . }

    }               shift and go to state 147


state 91

    (73) tableconstructor -> { } .

    ,               reduce using rule 73 (tableconstructor -> { } .)
    ;               reduce using rule 73 (tableconstructor -> { } .)
    LOCAL           reduce using rule 73 (tableconstructor -> { } .)
    FUNCTION        reduce using rule 73 (tableconstructor -> { } .)
    DO              reduce using rule 73 (tableconstructor -> { } .)
    WHILE           reduce using rule 73 (tableconstructor -> { } .)
    REPEAT          reduce using rule 73 (tableconstructor -> { } .)
    FOR             reduce using rule 73 (tableconstructor -> { } .)
    IF              reduce using rule 73 (tableconstructor -> { } .)
    (               reduce using rule 73 (tableconstructor -> { } .)
    IDENTIFIER      reduce using rule 73 (tableconstructor -> { } .)
    $end            reduce using rule 73 (tableconstructor -> { } .)
    END             reduce using rule 73 (tableconstructor -> { } .)
    UNTIL           reduce using rule 73 (tableconstructor -> { } .)
    ELSEIF          reduce using rule 73 (tableconstructor -> { } .)
    ELSE            reduce using rule 73 (tableconstructor -> { } .)
    CIRCUMFLEX      reduce using rule 73 (tableconstructor -> { } .)
    TIMES           reduce using rule 73 (tableconstructor -> { } .)
    DIVIDE          reduce using rule 73 (tableconstructor -> { } .)
    %               reduce using rule 73 (tableconstructor -> { } .)
    PLUS            reduce using rule 73 (tableconstructor -> { } .)
    MINUS           reduce using rule 73 (tableconstructor -> { } .)
    CONCAT          reduce using rule 73 (tableconstructor -> { } .)
    LT              reduce using rule 73 (tableconstructor -> { } .)
    LTE             reduce using rule 73 (tableconstructor -> { } .)
    GT              reduce using rule 73 (tableconstructor -> { } .)
    GTE             reduce using rule 73 (tableconstructor -> { } .)
    NE              reduce using rule 73 (tableconstructor -> { } .)
    EQUALS          reduce using rule 73 (tableconstructor -> { } .)
    AND             reduce using rule 73 (tableconstructor -> { } .)
    OR              reduce using rule 73 (tableconstructor -> { } .)
    RETURN          reduce using rule 73 (tableconstructor -> { } .)
    BREAK           reduce using rule 73 (tableconstructor -> { } .)
    :               reduce using rule 73 (tableconstructor -> { } .)
    [               reduce using rule 73 (tableconstructor -> { } .)
    .               reduce using rule 73 (tableconstructor -> { } .)
    {               reduce using rule 73 (tableconstructor -> { } .)
    STRING          reduce using rule 73 (tableconstructor -> { } .)
    THEN            reduce using rule 73 (tableconstructor -> { } .)
    )               reduce using rule 73 (tableconstructor -> { } .)
    }               reduce using rule 73 (tableconstructor -> { } .)
    ]               reduce using rule 73 (tableconstructor -> { } .)


state 92

    (77) fieldlist -> fieldlist2 . optfieldsep
    (79) fieldlist2 -> fieldlist2 . fieldsep field
    (80) optfieldsep -> . fieldsep
    (81) optfieldsep -> . empty
    (82) fieldsep -> . ,
    (83) fieldsep -> . ;
    (113) empty -> .

    ,               shift and go to state 151
    ;               shift and go to state 152
    }               reduce using rule 113 (empty -> .)

    optfieldsep                    shift and go to state 148
    fieldsep                       shift and go to state 149
    empty                          shift and go to state 150

state 93

    (78) fieldlist2 -> field .

    ,               reduce using rule 78 (fieldlist2 -> field .)
    ;               reduce using rule 78 (fieldlist2 -> field .)
    }               reduce using rule 78 (fieldlist2 -> field .)


state 94

    (74) field -> [ . exp ] = exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp

    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    exp                            shift and go to state 153
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57

state 95

    (76) field -> exp .
    (112) op_9 -> exp .

  ! reduce/reduce conflict for , resolved using rule 76 (field -> exp .)
  ! reduce/reduce conflict for ; resolved using rule 76 (field -> exp .)
  ! reduce/reduce conflict for } resolved using rule 76 (field -> exp .)
    ,               reduce using rule 76 (field -> exp .)
    ;               reduce using rule 76 (field -> exp .)
    }               reduce using rule 76 (field -> exp .)
    CIRCUMFLEX      reduce using rule 112 (op_9 -> exp .)
    TIMES           reduce using rule 112 (op_9 -> exp .)
    DIVIDE          reduce using rule 112 (op_9 -> exp .)
    %               reduce using rule 112 (op_9 -> exp .)
    PLUS            reduce using rule 112 (op_9 -> exp .)
    MINUS           reduce using rule 112 (op_9 -> exp .)
    CONCAT          reduce using rule 112 (op_9 -> exp .)
    LT              reduce using rule 112 (op_9 -> exp .)
    LTE             reduce using rule 112 (op_9 -> exp .)
    GT              reduce using rule 112 (op_9 -> exp .)
    GTE             reduce using rule 112 (op_9 -> exp .)
    NE              reduce using rule 112 (op_9 -> exp .)
    EQUALS          reduce using rule 112 (op_9 -> exp .)
    AND             reduce using rule 112 (op_9 -> exp .)
    OR              reduce using rule 112 (op_9 -> exp .)

  ! ,               [ reduce using rule 112 (op_9 -> exp .) ]
  ! ;               [ reduce using rule 112 (op_9 -> exp .) ]
  ! }               [ reduce using rule 112 (op_9 -> exp .) ]


state 96

    (75) field -> name . = exp
    (32) var -> name .

    =               shift and go to state 154
    [               reduce using rule 32 (var -> name .)
    .               reduce using rule 32 (var -> name .)
    :               reduce using rule 32 (var -> name .)
    (               reduce using rule 32 (var -> name .)
    {               reduce using rule 32 (var -> name .)
    STRING          reduce using rule 32 (var -> name .)
    ,               reduce using rule 32 (var -> name .)
    ;               reduce using rule 32 (var -> name .)
    }               reduce using rule 32 (var -> name .)
    CIRCUMFLEX      reduce using rule 32 (var -> name .)
    TIMES           reduce using rule 32 (var -> name .)
    DIVIDE          reduce using rule 32 (var -> name .)
    %               reduce using rule 32 (var -> name .)
    PLUS            reduce using rule 32 (var -> name .)
    MINUS           reduce using rule 32 (var -> name .)
    CONCAT          reduce using rule 32 (var -> name .)
    LT              reduce using rule 32 (var -> name .)
    LTE             reduce using rule 32 (var -> name .)
    GT              reduce using rule 32 (var -> name .)
    GTE             reduce using rule 32 (var -> name .)
    NE              reduce using rule 32 (var -> name .)
    EQUALS          reduce using rule 32 (var -> name .)
    AND             reduce using rule 32 (var -> name .)
    OR              reduce using rule 32 (var -> name .)


state 97

    (86) op_1 -> op_1 OR . op_2
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER

    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52
    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22

    op_1                           shift and go to state 46
    op_2                           shift and go to state 155
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57
    exp                            shift and go to state 112
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    name                           shift and go to state 11

state 98

    (88) op_2 -> op_2 AND . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3

    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52
    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22

    op_2                           shift and go to state 47
    op_3                           shift and go to state 156
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57
    exp                            shift and go to state 112
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11

state 99

    (90) op_3 -> op_3 LT . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4

    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52
    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22

    op_3                           shift and go to state 48
    op_4                           shift and go to state 157
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57
    exp                            shift and go to state 112
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47

state 100

    (91) op_3 -> op_3 LTE . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4

    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52
    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22

    op_3                           shift and go to state 48
    op_4                           shift and go to state 158
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57
    exp                            shift and go to state 112
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47

state 101

    (92) op_3 -> op_3 GT . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4

    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52
    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22

    op_3                           shift and go to state 48
    op_4                           shift and go to state 159
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57
    exp                            shift and go to state 112
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47

state 102

    (93) op_3 -> op_3 GTE . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4

    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52
    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22

    op_3                           shift and go to state 48
    op_4                           shift and go to state 160
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57
    exp                            shift and go to state 112
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47

state 103

    (94) op_3 -> op_3 NE . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4

    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52
    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22

    op_3                           shift and go to state 48
    op_4                           shift and go to state 161
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57
    exp                            shift and go to state 112
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47

state 104

    (95) op_3 -> op_3 EQUALS . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4

    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52
    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22

    op_3                           shift and go to state 48
    op_4                           shift and go to state 162
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57
    exp                            shift and go to state 112
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47

state 105

    (97) op_4 -> op_4 CONCAT . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5

    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52
    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22

    op_4                           shift and go to state 49
    op_5                           shift and go to state 163
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57
    exp                            shift and go to state 112
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48

state 106

    (99) op_5 -> op_5 PLUS . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6

    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52
    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22

    op_5                           shift and go to state 50
    op_6                           shift and go to state 164
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57
    exp                            shift and go to state 112
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49

state 107

    (100) op_5 -> op_5 MINUS . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6

    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52
    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22

    op_5                           shift and go to state 50
    op_6                           shift and go to state 165
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57
    exp                            shift and go to state 112
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49

state 108

    (102) op_6 -> op_6 TIMES . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7

    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52
    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22

    op_6                           shift and go to state 51
    op_7                           shift and go to state 166
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57
    exp                            shift and go to state 112
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50

state 109

    (103) op_6 -> op_6 DIVIDE . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7

    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52
    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22

    op_6                           shift and go to state 51
    op_7                           shift and go to state 167
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57
    exp                            shift and go to state 112
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50

state 110

    (104) op_6 -> op_6 % . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7

    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52
    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22

    op_6                           shift and go to state 51
    op_7                           shift and go to state 168
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57
    exp                            shift and go to state 112
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50

state 111

    (108) op_7 -> MINUS op_8 .
    (110) op_8 -> op_8 . CIRCUMFLEX op_9
    (109) op_7 -> op_8 .

  ! shift/reduce conflict for CIRCUMFLEX resolved as shift
  ! shift/reduce conflict for CIRCUMFLEX resolved as shift
  ! reduce/reduce conflict for , resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for ; resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for LOCAL resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for DO resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for WHILE resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for REPEAT resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for FOR resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for IF resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for ( resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for $end resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for END resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for UNTIL resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for ELSEIF resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for ELSE resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for TIMES resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for % resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for PLUS resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for MINUS resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for CONCAT resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for LT resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for LTE resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for GT resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for GTE resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for NE resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for EQUALS resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for AND resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for OR resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for THEN resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for ) resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for } resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for RETURN resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for BREAK resolved using rule 108 (op_7 -> MINUS op_8 .)
  ! reduce/reduce conflict for ] resolved using rule 108 (op_7 -> MINUS op_8 .)
    ,               reduce using rule 108 (op_7 -> MINUS op_8 .)
    ;               reduce using rule 108 (op_7 -> MINUS op_8 .)
    LOCAL           reduce using rule 108 (op_7 -> MINUS op_8 .)
    FUNCTION        reduce using rule 108 (op_7 -> MINUS op_8 .)
    DO              reduce using rule 108 (op_7 -> MINUS op_8 .)
    WHILE           reduce using rule 108 (op_7 -> MINUS op_8 .)
    REPEAT          reduce using rule 108 (op_7 -> MINUS op_8 .)
    FOR             reduce using rule 108 (op_7 -> MINUS op_8 .)
    IF              reduce using rule 108 (op_7 -> MINUS op_8 .)
    (               reduce using rule 108 (op_7 -> MINUS op_8 .)
    IDENTIFIER      reduce using rule 108 (op_7 -> MINUS op_8 .)
    $end            reduce using rule 108 (op_7 -> MINUS op_8 .)
    END             reduce using rule 108 (op_7 -> MINUS op_8 .)
    UNTIL           reduce using rule 108 (op_7 -> MINUS op_8 .)
    ELSEIF          reduce using rule 108 (op_7 -> MINUS op_8 .)
    ELSE            reduce using rule 108 (op_7 -> MINUS op_8 .)
    TIMES           reduce using rule 108 (op_7 -> MINUS op_8 .)
    DIVIDE          reduce using rule 108 (op_7 -> MINUS op_8 .)
    %               reduce using rule 108 (op_7 -> MINUS op_8 .)
    PLUS            reduce using rule 108 (op_7 -> MINUS op_8 .)
    MINUS           reduce using rule 108 (op_7 -> MINUS op_8 .)
    CONCAT          reduce using rule 108 (op_7 -> MINUS op_8 .)
    LT              reduce using rule 108 (op_7 -> MINUS op_8 .)
    LTE             reduce using rule 108 (op_7 -> MINUS op_8 .)
    GT              reduce using rule 108 (op_7 -> MINUS op_8 .)
    GTE             reduce using rule 108 (op_7 -> MINUS op_8 .)
    NE              reduce using rule 108 (op_7 -> MINUS op_8 .)
    EQUALS          reduce using rule 108 (op_7 -> MINUS op_8 .)
    AND             reduce using rule 108 (op_7 -> MINUS op_8 .)
    OR              reduce using rule 108 (op_7 -> MINUS op_8 .)
    THEN            reduce using rule 108 (op_7 -> MINUS op_8 .)
    )               reduce using rule 108 (op_7 -> MINUS op_8 .)
    }               reduce using rule 108 (op_7 -> MINUS op_8 .)
    RETURN          reduce using rule 108 (op_7 -> MINUS op_8 .)
    BREAK           reduce using rule 108 (op_7 -> MINUS op_8 .)
    ]               reduce using rule 108 (op_7 -> MINUS op_8 .)
    CIRCUMFLEX      shift and go to state 114

  ! CIRCUMFLEX      [ reduce using rule 108 (op_7 -> MINUS op_8 .) ]
  ! CIRCUMFLEX      [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! ,               [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! ;               [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! LOCAL           [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! FUNCTION        [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! DO              [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! WHILE           [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! REPEAT          [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! FOR             [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! IF              [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! (               [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! IDENTIFIER      [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! $end            [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! END             [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! UNTIL           [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! ELSEIF          [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! ELSE            [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! TIMES           [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! DIVIDE          [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! %               [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! PLUS            [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! MINUS           [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! CONCAT          [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! LT              [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! LTE             [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! GT              [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! GTE             [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! NE              [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! EQUALS          [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! AND             [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! OR              [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! THEN            [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! )               [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! }               [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! RETURN          [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! BREAK           [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! ]               [ reduce using rule 109 (op_7 -> op_8 .) ]


state 112

    (112) op_9 -> exp .

    CIRCUMFLEX      reduce using rule 112 (op_9 -> exp .)
    ,               reduce using rule 112 (op_9 -> exp .)
    ;               reduce using rule 112 (op_9 -> exp .)
    LOCAL           reduce using rule 112 (op_9 -> exp .)
    FUNCTION        reduce using rule 112 (op_9 -> exp .)
    DO              reduce using rule 112 (op_9 -> exp .)
    WHILE           reduce using rule 112 (op_9 -> exp .)
    REPEAT          reduce using rule 112 (op_9 -> exp .)
    FOR             reduce using rule 112 (op_9 -> exp .)
    IF              reduce using rule 112 (op_9 -> exp .)
    (               reduce using rule 112 (op_9 -> exp .)
    IDENTIFIER      reduce using rule 112 (op_9 -> exp .)
    $end            reduce using rule 112 (op_9 -> exp .)
    END             reduce using rule 112 (op_9 -> exp .)
    UNTIL           reduce using rule 112 (op_9 -> exp .)
    ELSEIF          reduce using rule 112 (op_9 -> exp .)
    ELSE            reduce using rule 112 (op_9 -> exp .)
    TIMES           reduce using rule 112 (op_9 -> exp .)
    DIVIDE          reduce using rule 112 (op_9 -> exp .)
    %               reduce using rule 112 (op_9 -> exp .)
    PLUS            reduce using rule 112 (op_9 -> exp .)
    MINUS           reduce using rule 112 (op_9 -> exp .)
    CONCAT          reduce using rule 112 (op_9 -> exp .)
    LT              reduce using rule 112 (op_9 -> exp .)
    LTE             reduce using rule 112 (op_9 -> exp .)
    GT              reduce using rule 112 (op_9 -> exp .)
    GTE             reduce using rule 112 (op_9 -> exp .)
    NE              reduce using rule 112 (op_9 -> exp .)
    EQUALS          reduce using rule 112 (op_9 -> exp .)
    AND             reduce using rule 112 (op_9 -> exp .)
    OR              reduce using rule 112 (op_9 -> exp .)
    THEN            reduce using rule 112 (op_9 -> exp .)
    )               reduce using rule 112 (op_9 -> exp .)
    }               reduce using rule 112 (op_9 -> exp .)
    RETURN          reduce using rule 112 (op_9 -> exp .)
    BREAK           reduce using rule 112 (op_9 -> exp .)
    ]               reduce using rule 112 (op_9 -> exp .)


state 113

    (106) op_7 -> NOT op_8 .
    (110) op_8 -> op_8 . CIRCUMFLEX op_9
    (109) op_7 -> op_8 .

  ! shift/reduce conflict for CIRCUMFLEX resolved as shift
  ! shift/reduce conflict for CIRCUMFLEX resolved as shift
  ! reduce/reduce conflict for , resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for ; resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for LOCAL resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for DO resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for WHILE resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for REPEAT resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for FOR resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for IF resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for ( resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for $end resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for END resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for UNTIL resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for ELSEIF resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for ELSE resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for TIMES resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for % resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for PLUS resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for MINUS resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for CONCAT resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for LT resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for LTE resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for GT resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for GTE resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for NE resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for EQUALS resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for AND resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for OR resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for THEN resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for ) resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for } resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for RETURN resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for BREAK resolved using rule 106 (op_7 -> NOT op_8 .)
  ! reduce/reduce conflict for ] resolved using rule 106 (op_7 -> NOT op_8 .)
    ,               reduce using rule 106 (op_7 -> NOT op_8 .)
    ;               reduce using rule 106 (op_7 -> NOT op_8 .)
    LOCAL           reduce using rule 106 (op_7 -> NOT op_8 .)
    FUNCTION        reduce using rule 106 (op_7 -> NOT op_8 .)
    DO              reduce using rule 106 (op_7 -> NOT op_8 .)
    WHILE           reduce using rule 106 (op_7 -> NOT op_8 .)
    REPEAT          reduce using rule 106 (op_7 -> NOT op_8 .)
    FOR             reduce using rule 106 (op_7 -> NOT op_8 .)
    IF              reduce using rule 106 (op_7 -> NOT op_8 .)
    (               reduce using rule 106 (op_7 -> NOT op_8 .)
    IDENTIFIER      reduce using rule 106 (op_7 -> NOT op_8 .)
    $end            reduce using rule 106 (op_7 -> NOT op_8 .)
    END             reduce using rule 106 (op_7 -> NOT op_8 .)
    UNTIL           reduce using rule 106 (op_7 -> NOT op_8 .)
    ELSEIF          reduce using rule 106 (op_7 -> NOT op_8 .)
    ELSE            reduce using rule 106 (op_7 -> NOT op_8 .)
    TIMES           reduce using rule 106 (op_7 -> NOT op_8 .)
    DIVIDE          reduce using rule 106 (op_7 -> NOT op_8 .)
    %               reduce using rule 106 (op_7 -> NOT op_8 .)
    PLUS            reduce using rule 106 (op_7 -> NOT op_8 .)
    MINUS           reduce using rule 106 (op_7 -> NOT op_8 .)
    CONCAT          reduce using rule 106 (op_7 -> NOT op_8 .)
    LT              reduce using rule 106 (op_7 -> NOT op_8 .)
    LTE             reduce using rule 106 (op_7 -> NOT op_8 .)
    GT              reduce using rule 106 (op_7 -> NOT op_8 .)
    GTE             reduce using rule 106 (op_7 -> NOT op_8 .)
    NE              reduce using rule 106 (op_7 -> NOT op_8 .)
    EQUALS          reduce using rule 106 (op_7 -> NOT op_8 .)
    AND             reduce using rule 106 (op_7 -> NOT op_8 .)
    OR              reduce using rule 106 (op_7 -> NOT op_8 .)
    THEN            reduce using rule 106 (op_7 -> NOT op_8 .)
    )               reduce using rule 106 (op_7 -> NOT op_8 .)
    }               reduce using rule 106 (op_7 -> NOT op_8 .)
    RETURN          reduce using rule 106 (op_7 -> NOT op_8 .)
    BREAK           reduce using rule 106 (op_7 -> NOT op_8 .)
    ]               reduce using rule 106 (op_7 -> NOT op_8 .)
    CIRCUMFLEX      shift and go to state 114

  ! CIRCUMFLEX      [ reduce using rule 106 (op_7 -> NOT op_8 .) ]
  ! CIRCUMFLEX      [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! ,               [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! ;               [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! LOCAL           [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! FUNCTION        [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! DO              [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! WHILE           [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! REPEAT          [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! FOR             [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! IF              [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! (               [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! IDENTIFIER      [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! $end            [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! END             [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! UNTIL           [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! ELSEIF          [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! ELSE            [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! TIMES           [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! DIVIDE          [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! %               [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! PLUS            [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! MINUS           [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! CONCAT          [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! LT              [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! LTE             [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! GT              [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! GTE             [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! NE              [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! EQUALS          [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! AND             [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! OR              [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! THEN            [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! )               [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! }               [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! RETURN          [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! BREAK           [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! ]               [ reduce using rule 109 (op_7 -> op_8 .) ]


state 114

    (110) op_8 -> op_8 CIRCUMFLEX . op_9
    (112) op_9 -> . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9

    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    op_8                           shift and go to state 55
    op_9                           shift and go to state 169
    exp                            shift and go to state 112
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53

state 115

    (107) op_7 -> HASH op_8 .
    (110) op_8 -> op_8 . CIRCUMFLEX op_9
    (109) op_7 -> op_8 .

  ! shift/reduce conflict for CIRCUMFLEX resolved as shift
  ! shift/reduce conflict for CIRCUMFLEX resolved as shift
  ! reduce/reduce conflict for , resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for ; resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for LOCAL resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for DO resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for WHILE resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for REPEAT resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for FOR resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for IF resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for ( resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for $end resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for END resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for UNTIL resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for ELSEIF resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for ELSE resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for TIMES resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for % resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for PLUS resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for MINUS resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for CONCAT resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for LT resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for LTE resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for GT resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for GTE resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for NE resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for EQUALS resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for AND resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for OR resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for THEN resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for ) resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for } resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for RETURN resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for BREAK resolved using rule 107 (op_7 -> HASH op_8 .)
  ! reduce/reduce conflict for ] resolved using rule 107 (op_7 -> HASH op_8 .)
    ,               reduce using rule 107 (op_7 -> HASH op_8 .)
    ;               reduce using rule 107 (op_7 -> HASH op_8 .)
    LOCAL           reduce using rule 107 (op_7 -> HASH op_8 .)
    FUNCTION        reduce using rule 107 (op_7 -> HASH op_8 .)
    DO              reduce using rule 107 (op_7 -> HASH op_8 .)
    WHILE           reduce using rule 107 (op_7 -> HASH op_8 .)
    REPEAT          reduce using rule 107 (op_7 -> HASH op_8 .)
    FOR             reduce using rule 107 (op_7 -> HASH op_8 .)
    IF              reduce using rule 107 (op_7 -> HASH op_8 .)
    (               reduce using rule 107 (op_7 -> HASH op_8 .)
    IDENTIFIER      reduce using rule 107 (op_7 -> HASH op_8 .)
    $end            reduce using rule 107 (op_7 -> HASH op_8 .)
    END             reduce using rule 107 (op_7 -> HASH op_8 .)
    UNTIL           reduce using rule 107 (op_7 -> HASH op_8 .)
    ELSEIF          reduce using rule 107 (op_7 -> HASH op_8 .)
    ELSE            reduce using rule 107 (op_7 -> HASH op_8 .)
    TIMES           reduce using rule 107 (op_7 -> HASH op_8 .)
    DIVIDE          reduce using rule 107 (op_7 -> HASH op_8 .)
    %               reduce using rule 107 (op_7 -> HASH op_8 .)
    PLUS            reduce using rule 107 (op_7 -> HASH op_8 .)
    MINUS           reduce using rule 107 (op_7 -> HASH op_8 .)
    CONCAT          reduce using rule 107 (op_7 -> HASH op_8 .)
    LT              reduce using rule 107 (op_7 -> HASH op_8 .)
    LTE             reduce using rule 107 (op_7 -> HASH op_8 .)
    GT              reduce using rule 107 (op_7 -> HASH op_8 .)
    GTE             reduce using rule 107 (op_7 -> HASH op_8 .)
    NE              reduce using rule 107 (op_7 -> HASH op_8 .)
    EQUALS          reduce using rule 107 (op_7 -> HASH op_8 .)
    AND             reduce using rule 107 (op_7 -> HASH op_8 .)
    OR              reduce using rule 107 (op_7 -> HASH op_8 .)
    THEN            reduce using rule 107 (op_7 -> HASH op_8 .)
    )               reduce using rule 107 (op_7 -> HASH op_8 .)
    }               reduce using rule 107 (op_7 -> HASH op_8 .)
    RETURN          reduce using rule 107 (op_7 -> HASH op_8 .)
    BREAK           reduce using rule 107 (op_7 -> HASH op_8 .)
    ]               reduce using rule 107 (op_7 -> HASH op_8 .)
    CIRCUMFLEX      shift and go to state 114

  ! CIRCUMFLEX      [ reduce using rule 107 (op_7 -> HASH op_8 .) ]
  ! CIRCUMFLEX      [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! ,               [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! ;               [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! LOCAL           [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! FUNCTION        [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! DO              [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! WHILE           [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! REPEAT          [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! FOR             [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! IF              [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! (               [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! IDENTIFIER      [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! $end            [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! END             [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! UNTIL           [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! ELSEIF          [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! ELSE            [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! TIMES           [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! DIVIDE          [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! %               [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! PLUS            [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! MINUS           [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! CONCAT          [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! LT              [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! LTE             [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! GT              [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! GTE             [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! NE              [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! EQUALS          [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! AND             [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! OR              [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! THEN            [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! )               [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! }               [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! RETURN          [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! BREAK           [ reduce using rule 109 (op_7 -> op_8 .) ]
  ! ]               [ reduce using rule 109 (op_7 -> op_8 .) ]


state 116

    (12) stat -> varlist = explist .
    (55) explist -> explist . , exp

    ;               reduce using rule 12 (stat -> varlist = explist .)
    RETURN          reduce using rule 12 (stat -> varlist = explist .)
    BREAK           reduce using rule 12 (stat -> varlist = explist .)
    LOCAL           reduce using rule 12 (stat -> varlist = explist .)
    FUNCTION        reduce using rule 12 (stat -> varlist = explist .)
    DO              reduce using rule 12 (stat -> varlist = explist .)
    WHILE           reduce using rule 12 (stat -> varlist = explist .)
    REPEAT          reduce using rule 12 (stat -> varlist = explist .)
    FOR             reduce using rule 12 (stat -> varlist = explist .)
    IF              reduce using rule 12 (stat -> varlist = explist .)
    (               reduce using rule 12 (stat -> varlist = explist .)
    IDENTIFIER      reduce using rule 12 (stat -> varlist = explist .)
    $end            reduce using rule 12 (stat -> varlist = explist .)
    END             reduce using rule 12 (stat -> varlist = explist .)
    UNTIL           reduce using rule 12 (stat -> varlist = explist .)
    ELSEIF          reduce using rule 12 (stat -> varlist = explist .)
    ELSE            reduce using rule 12 (stat -> varlist = explist .)
    ,               shift and go to state 87


state 117

    (36) varlist -> varlist , var .
    (56) prefixexp -> var .

    =               reduce using rule 36 (varlist -> varlist , var .)
    ,               reduce using rule 36 (varlist -> varlist , var .)
    [               reduce using rule 56 (prefixexp -> var .)
    .               reduce using rule 56 (prefixexp -> var .)
    :               reduce using rule 56 (prefixexp -> var .)
    (               reduce using rule 56 (prefixexp -> var .)
    {               reduce using rule 56 (prefixexp -> var .)
    STRING          reduce using rule 56 (prefixexp -> var .)


state 118

    (33) var -> prefixexp . [ exp ]
    (34) var -> prefixexp . . name
    (60) functioncall -> prefixexp . args
    (61) functioncall -> prefixexp . : name args
    (68) args -> . ( )
    (69) args -> . ( explist )
    (70) args -> . tableconstructor
    (71) args -> . string
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (84) string -> . STRING

    [               shift and go to state 78
    .               shift and go to state 79
    :               shift and go to state 77
    (               shift and go to state 80
    {               shift and go to state 45
    STRING          shift and go to state 41

    args                           shift and go to state 76
    tableconstructor               shift and go to state 81
    string                         shift and go to state 82

state 119

    (13) stat -> LOCAL namelist = . explist
    (54) explist -> . exp
    (55) explist -> . explist , exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp

    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    explist                        shift and go to state 170
    exp                            shift and go to state 30
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57

state 120

    (43) namelist -> namelist , . name
    (37) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 22

    name                           shift and go to state 171

state 121

    (16) stat -> LOCAL FUNCTION name . funcbody
    (63) funcbody -> . ( parlist ) block END
    (64) funcbody -> . ( ) block END

    (               shift and go to state 89

    funcbody                       shift and go to state 172

state 122

    (15) stat -> FUNCTION funcname funcbody .

    ;               reduce using rule 15 (stat -> FUNCTION funcname funcbody .)
    RETURN          reduce using rule 15 (stat -> FUNCTION funcname funcbody .)
    BREAK           reduce using rule 15 (stat -> FUNCTION funcname funcbody .)
    LOCAL           reduce using rule 15 (stat -> FUNCTION funcname funcbody .)
    FUNCTION        reduce using rule 15 (stat -> FUNCTION funcname funcbody .)
    DO              reduce using rule 15 (stat -> FUNCTION funcname funcbody .)
    WHILE           reduce using rule 15 (stat -> FUNCTION funcname funcbody .)
    REPEAT          reduce using rule 15 (stat -> FUNCTION funcname funcbody .)
    FOR             reduce using rule 15 (stat -> FUNCTION funcname funcbody .)
    IF              reduce using rule 15 (stat -> FUNCTION funcname funcbody .)
    (               reduce using rule 15 (stat -> FUNCTION funcname funcbody .)
    IDENTIFIER      reduce using rule 15 (stat -> FUNCTION funcname funcbody .)
    $end            reduce using rule 15 (stat -> FUNCTION funcname funcbody .)
    END             reduce using rule 15 (stat -> FUNCTION funcname funcbody .)
    UNTIL           reduce using rule 15 (stat -> FUNCTION funcname funcbody .)
    ELSEIF          reduce using rule 15 (stat -> FUNCTION funcname funcbody .)
    ELSE            reduce using rule 15 (stat -> FUNCTION funcname funcbody .)


state 123

    (39) funcname -> funcname2 : . name
    (37) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 22

    name                           shift and go to state 173

state 124

    (41) funcname2 -> funcname2 . . name
    (37) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 22

    name                           shift and go to state 174

state 125

    (18) stat -> DO block END .

    ;               reduce using rule 18 (stat -> DO block END .)
    RETURN          reduce using rule 18 (stat -> DO block END .)
    BREAK           reduce using rule 18 (stat -> DO block END .)
    LOCAL           reduce using rule 18 (stat -> DO block END .)
    FUNCTION        reduce using rule 18 (stat -> DO block END .)
    DO              reduce using rule 18 (stat -> DO block END .)
    WHILE           reduce using rule 18 (stat -> DO block END .)
    REPEAT          reduce using rule 18 (stat -> DO block END .)
    FOR             reduce using rule 18 (stat -> DO block END .)
    IF              reduce using rule 18 (stat -> DO block END .)
    (               reduce using rule 18 (stat -> DO block END .)
    IDENTIFIER      reduce using rule 18 (stat -> DO block END .)
    $end            reduce using rule 18 (stat -> DO block END .)
    END             reduce using rule 18 (stat -> DO block END .)
    UNTIL           reduce using rule 18 (stat -> DO block END .)
    ELSEIF          reduce using rule 18 (stat -> DO block END .)
    ELSE            reduce using rule 18 (stat -> DO block END .)


state 126

    (19) stat -> WHILE exp DO . block END
    (1) block -> . chunk
    (2) chunk -> . chunk2 laststat
    (3) chunk -> . chunk2
    (4) chunk -> . laststat
    (5) chunk2 -> . stat optsemi
    (6) chunk2 -> . chunk stat optsemi
    (9) laststat -> . RETURN explist optsemi
    (10) laststat -> . RETURN optsemi
    (11) laststat -> . BREAK optsemi
    (12) stat -> . varlist = explist
    (13) stat -> . LOCAL namelist = explist
    (14) stat -> . LOCAL namelist
    (15) stat -> . FUNCTION funcname funcbody
    (16) stat -> . LOCAL FUNCTION name funcbody
    (17) stat -> . functioncall
    (18) stat -> . DO block END
    (19) stat -> . WHILE exp DO block END
    (20) stat -> . REPEAT block UNTIL exp
    (21) stat -> . if elseiflist else END
    (22) stat -> . FOR name = exp , exp DO block END
    (23) stat -> . FOR name = exp , exp , exp DO block END
    (24) stat -> . FOR namelist IN explist DO block END
    (35) varlist -> . var
    (36) varlist -> . varlist , var
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (25) if -> . IF exp THEN block
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (37) name -> . IDENTIFIER

    RETURN          shift and go to state 6
    BREAK           shift and go to state 7
    LOCAL           shift and go to state 9
    FUNCTION        shift and go to state 10
    DO              shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    FOR             shift and go to state 17
    IF              shift and go to state 20
    (               shift and go to state 21
    IDENTIFIER      shift and go to state 22

    block                          shift and go to state 175
    chunk                          shift and go to state 2
    chunk2                         shift and go to state 3
    laststat                       shift and go to state 4
    stat                           shift and go to state 5
    varlist                        shift and go to state 8
    name                           shift and go to state 11
    functioncall                   shift and go to state 12
    if                             shift and go to state 16
    var                            shift and go to state 18
    prefixexp                      shift and go to state 19

state 127

    (20) stat -> REPEAT block UNTIL . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp

    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    exp                            shift and go to state 176
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57

state 128

    (21) stat -> if elseiflist else . END

    END             shift and go to state 177


state 129

    (27) elseiflist -> elseiflist elseif .

    ELSE            reduce using rule 27 (elseiflist -> elseiflist elseif .)
    ELSEIF          reduce using rule 27 (elseiflist -> elseiflist elseif .)
    END             reduce using rule 27 (elseiflist -> elseiflist elseif .)


state 130

    (30) else -> ELSE . block
    (1) block -> . chunk
    (2) chunk -> . chunk2 laststat
    (3) chunk -> . chunk2
    (4) chunk -> . laststat
    (5) chunk2 -> . stat optsemi
    (6) chunk2 -> . chunk stat optsemi
    (9) laststat -> . RETURN explist optsemi
    (10) laststat -> . RETURN optsemi
    (11) laststat -> . BREAK optsemi
    (12) stat -> . varlist = explist
    (13) stat -> . LOCAL namelist = explist
    (14) stat -> . LOCAL namelist
    (15) stat -> . FUNCTION funcname funcbody
    (16) stat -> . LOCAL FUNCTION name funcbody
    (17) stat -> . functioncall
    (18) stat -> . DO block END
    (19) stat -> . WHILE exp DO block END
    (20) stat -> . REPEAT block UNTIL exp
    (21) stat -> . if elseiflist else END
    (22) stat -> . FOR name = exp , exp DO block END
    (23) stat -> . FOR name = exp , exp , exp DO block END
    (24) stat -> . FOR namelist IN explist DO block END
    (35) varlist -> . var
    (36) varlist -> . varlist , var
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (25) if -> . IF exp THEN block
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (37) name -> . IDENTIFIER

    RETURN          shift and go to state 6
    BREAK           shift and go to state 7
    LOCAL           shift and go to state 9
    FUNCTION        shift and go to state 10
    DO              shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    FOR             shift and go to state 17
    IF              shift and go to state 20
    (               shift and go to state 21
    IDENTIFIER      shift and go to state 22

    block                          shift and go to state 178
    chunk                          shift and go to state 2
    chunk2                         shift and go to state 3
    laststat                       shift and go to state 4
    stat                           shift and go to state 5
    varlist                        shift and go to state 8
    name                           shift and go to state 11
    functioncall                   shift and go to state 12
    if                             shift and go to state 16
    var                            shift and go to state 18
    prefixexp                      shift and go to state 19

state 131

    (31) else -> empty .

    END             reduce using rule 31 (else -> empty .)


state 132

    (29) elseif -> ELSEIF exp . THEN block
    (112) op_9 -> exp .

  ! shift/reduce conflict for THEN resolved as shift
    THEN            shift and go to state 179
    TIMES           reduce using rule 112 (op_9 -> exp .)
    DIVIDE          reduce using rule 112 (op_9 -> exp .)
    %               reduce using rule 112 (op_9 -> exp .)
    PLUS            reduce using rule 112 (op_9 -> exp .)
    MINUS           reduce using rule 112 (op_9 -> exp .)
    CONCAT          reduce using rule 112 (op_9 -> exp .)
    LT              reduce using rule 112 (op_9 -> exp .)
    LTE             reduce using rule 112 (op_9 -> exp .)
    GT              reduce using rule 112 (op_9 -> exp .)
    GTE             reduce using rule 112 (op_9 -> exp .)
    NE              reduce using rule 112 (op_9 -> exp .)
    EQUALS          reduce using rule 112 (op_9 -> exp .)
    AND             reduce using rule 112 (op_9 -> exp .)
    OR              reduce using rule 112 (op_9 -> exp .)
    CIRCUMFLEX      reduce using rule 112 (op_9 -> exp .)

  ! THEN            [ reduce using rule 112 (op_9 -> exp .) ]


state 133

    (22) stat -> FOR name = . exp , exp DO block END
    (23) stat -> FOR name = . exp , exp , exp DO block END
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp

    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    name                           shift and go to state 11
    exp                            shift and go to state 180
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57

state 134

    (24) stat -> FOR namelist IN . explist DO block END
    (54) explist -> . exp
    (55) explist -> . explist , exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp

    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    explist                        shift and go to state 181
    exp                            shift and go to state 30
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57

state 135

    (61) functioncall -> prefixexp : name . args
    (68) args -> . ( )
    (69) args -> . ( explist )
    (70) args -> . tableconstructor
    (71) args -> . string
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (84) string -> . STRING

    (               shift and go to state 80
    {               shift and go to state 45
    STRING          shift and go to state 41

    args                           shift and go to state 182
    tableconstructor               shift and go to state 81
    string                         shift and go to state 82

state 136

    (33) var -> prefixexp [ exp . ]
    (112) op_9 -> exp .

  ! shift/reduce conflict for ] resolved as shift
    ]               shift and go to state 183
    TIMES           reduce using rule 112 (op_9 -> exp .)
    DIVIDE          reduce using rule 112 (op_9 -> exp .)
    %               reduce using rule 112 (op_9 -> exp .)
    PLUS            reduce using rule 112 (op_9 -> exp .)
    MINUS           reduce using rule 112 (op_9 -> exp .)
    CONCAT          reduce using rule 112 (op_9 -> exp .)
    LT              reduce using rule 112 (op_9 -> exp .)
    LTE             reduce using rule 112 (op_9 -> exp .)
    GT              reduce using rule 112 (op_9 -> exp .)
    GTE             reduce using rule 112 (op_9 -> exp .)
    NE              reduce using rule 112 (op_9 -> exp .)
    EQUALS          reduce using rule 112 (op_9 -> exp .)
    AND             reduce using rule 112 (op_9 -> exp .)
    OR              reduce using rule 112 (op_9 -> exp .)
    CIRCUMFLEX      reduce using rule 112 (op_9 -> exp .)

  ! ]               [ reduce using rule 112 (op_9 -> exp .) ]


state 137

    (34) var -> prefixexp . name .

    =               reduce using rule 34 (var -> prefixexp . name .)
    ,               reduce using rule 34 (var -> prefixexp . name .)
    :               reduce using rule 34 (var -> prefixexp . name .)
    [               reduce using rule 34 (var -> prefixexp . name .)
    .               reduce using rule 34 (var -> prefixexp . name .)
    (               reduce using rule 34 (var -> prefixexp . name .)
    {               reduce using rule 34 (var -> prefixexp . name .)
    STRING          reduce using rule 34 (var -> prefixexp . name .)
    ;               reduce using rule 34 (var -> prefixexp . name .)
    LOCAL           reduce using rule 34 (var -> prefixexp . name .)
    FUNCTION        reduce using rule 34 (var -> prefixexp . name .)
    DO              reduce using rule 34 (var -> prefixexp . name .)
    WHILE           reduce using rule 34 (var -> prefixexp . name .)
    REPEAT          reduce using rule 34 (var -> prefixexp . name .)
    FOR             reduce using rule 34 (var -> prefixexp . name .)
    IF              reduce using rule 34 (var -> prefixexp . name .)
    IDENTIFIER      reduce using rule 34 (var -> prefixexp . name .)
    $end            reduce using rule 34 (var -> prefixexp . name .)
    END             reduce using rule 34 (var -> prefixexp . name .)
    UNTIL           reduce using rule 34 (var -> prefixexp . name .)
    ELSEIF          reduce using rule 34 (var -> prefixexp . name .)
    ELSE            reduce using rule 34 (var -> prefixexp . name .)
    CIRCUMFLEX      reduce using rule 34 (var -> prefixexp . name .)
    TIMES           reduce using rule 34 (var -> prefixexp . name .)
    DIVIDE          reduce using rule 34 (var -> prefixexp . name .)
    %               reduce using rule 34 (var -> prefixexp . name .)
    PLUS            reduce using rule 34 (var -> prefixexp . name .)
    MINUS           reduce using rule 34 (var -> prefixexp . name .)
    CONCAT          reduce using rule 34 (var -> prefixexp . name .)
    LT              reduce using rule 34 (var -> prefixexp . name .)
    LTE             reduce using rule 34 (var -> prefixexp . name .)
    GT              reduce using rule 34 (var -> prefixexp . name .)
    GTE             reduce using rule 34 (var -> prefixexp . name .)
    NE              reduce using rule 34 (var -> prefixexp . name .)
    EQUALS          reduce using rule 34 (var -> prefixexp . name .)
    AND             reduce using rule 34 (var -> prefixexp . name .)
    OR              reduce using rule 34 (var -> prefixexp . name .)
    THEN            reduce using rule 34 (var -> prefixexp . name .)
    )               reduce using rule 34 (var -> prefixexp . name .)
    }               reduce using rule 34 (var -> prefixexp . name .)
    RETURN          reduce using rule 34 (var -> prefixexp . name .)
    BREAK           reduce using rule 34 (var -> prefixexp . name .)
    ]               reduce using rule 34 (var -> prefixexp . name .)


state 138

    (68) args -> ( ) .

    ;               reduce using rule 68 (args -> ( ) .)
    RETURN          reduce using rule 68 (args -> ( ) .)
    BREAK           reduce using rule 68 (args -> ( ) .)
    LOCAL           reduce using rule 68 (args -> ( ) .)
    FUNCTION        reduce using rule 68 (args -> ( ) .)
    DO              reduce using rule 68 (args -> ( ) .)
    WHILE           reduce using rule 68 (args -> ( ) .)
    REPEAT          reduce using rule 68 (args -> ( ) .)
    FOR             reduce using rule 68 (args -> ( ) .)
    IF              reduce using rule 68 (args -> ( ) .)
    (               reduce using rule 68 (args -> ( ) .)
    IDENTIFIER      reduce using rule 68 (args -> ( ) .)
    $end            reduce using rule 68 (args -> ( ) .)
    :               reduce using rule 68 (args -> ( ) .)
    [               reduce using rule 68 (args -> ( ) .)
    .               reduce using rule 68 (args -> ( ) .)
    {               reduce using rule 68 (args -> ( ) .)
    STRING          reduce using rule 68 (args -> ( ) .)
    END             reduce using rule 68 (args -> ( ) .)
    UNTIL           reduce using rule 68 (args -> ( ) .)
    ELSEIF          reduce using rule 68 (args -> ( ) .)
    ELSE            reduce using rule 68 (args -> ( ) .)
    ,               reduce using rule 68 (args -> ( ) .)
    CIRCUMFLEX      reduce using rule 68 (args -> ( ) .)
    TIMES           reduce using rule 68 (args -> ( ) .)
    DIVIDE          reduce using rule 68 (args -> ( ) .)
    %               reduce using rule 68 (args -> ( ) .)
    PLUS            reduce using rule 68 (args -> ( ) .)
    MINUS           reduce using rule 68 (args -> ( ) .)
    CONCAT          reduce using rule 68 (args -> ( ) .)
    LT              reduce using rule 68 (args -> ( ) .)
    LTE             reduce using rule 68 (args -> ( ) .)
    GT              reduce using rule 68 (args -> ( ) .)
    GTE             reduce using rule 68 (args -> ( ) .)
    NE              reduce using rule 68 (args -> ( ) .)
    EQUALS          reduce using rule 68 (args -> ( ) .)
    AND             reduce using rule 68 (args -> ( ) .)
    OR              reduce using rule 68 (args -> ( ) .)
    THEN            reduce using rule 68 (args -> ( ) .)
    )               reduce using rule 68 (args -> ( ) .)
    }               reduce using rule 68 (args -> ( ) .)
    ]               reduce using rule 68 (args -> ( ) .)


state 139

    (69) args -> ( explist . )
    (55) explist -> explist . , exp

    )               shift and go to state 184
    ,               shift and go to state 87


state 140

    (25) if -> IF exp THEN . block
    (1) block -> . chunk
    (2) chunk -> . chunk2 laststat
    (3) chunk -> . chunk2
    (4) chunk -> . laststat
    (5) chunk2 -> . stat optsemi
    (6) chunk2 -> . chunk stat optsemi
    (9) laststat -> . RETURN explist optsemi
    (10) laststat -> . RETURN optsemi
    (11) laststat -> . BREAK optsemi
    (12) stat -> . varlist = explist
    (13) stat -> . LOCAL namelist = explist
    (14) stat -> . LOCAL namelist
    (15) stat -> . FUNCTION funcname funcbody
    (16) stat -> . LOCAL FUNCTION name funcbody
    (17) stat -> . functioncall
    (18) stat -> . DO block END
    (19) stat -> . WHILE exp DO block END
    (20) stat -> . REPEAT block UNTIL exp
    (21) stat -> . if elseiflist else END
    (22) stat -> . FOR name = exp , exp DO block END
    (23) stat -> . FOR name = exp , exp , exp DO block END
    (24) stat -> . FOR namelist IN explist DO block END
    (35) varlist -> . var
    (36) varlist -> . varlist , var
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (25) if -> . IF exp THEN block
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (37) name -> . IDENTIFIER

    RETURN          shift and go to state 6
    BREAK           shift and go to state 7
    LOCAL           shift and go to state 9
    FUNCTION        shift and go to state 10
    DO              shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    FOR             shift and go to state 17
    IF              shift and go to state 20
    (               shift and go to state 21
    IDENTIFIER      shift and go to state 22

    block                          shift and go to state 185
    chunk                          shift and go to state 2
    chunk2                         shift and go to state 3
    laststat                       shift and go to state 4
    stat                           shift and go to state 5
    varlist                        shift and go to state 8
    name                           shift and go to state 11
    functioncall                   shift and go to state 12
    if                             shift and go to state 16
    var                            shift and go to state 18
    prefixexp                      shift and go to state 19

state 141

    (58) prefixexp -> ( exp ) .

    :               reduce using rule 58 (prefixexp -> ( exp ) .)
    [               reduce using rule 58 (prefixexp -> ( exp ) .)
    .               reduce using rule 58 (prefixexp -> ( exp ) .)
    (               reduce using rule 58 (prefixexp -> ( exp ) .)
    {               reduce using rule 58 (prefixexp -> ( exp ) .)
    STRING          reduce using rule 58 (prefixexp -> ( exp ) .)
    ,               reduce using rule 58 (prefixexp -> ( exp ) .)
    ;               reduce using rule 58 (prefixexp -> ( exp ) .)
    LOCAL           reduce using rule 58 (prefixexp -> ( exp ) .)
    FUNCTION        reduce using rule 58 (prefixexp -> ( exp ) .)
    DO              reduce using rule 58 (prefixexp -> ( exp ) .)
    WHILE           reduce using rule 58 (prefixexp -> ( exp ) .)
    REPEAT          reduce using rule 58 (prefixexp -> ( exp ) .)
    FOR             reduce using rule 58 (prefixexp -> ( exp ) .)
    IF              reduce using rule 58 (prefixexp -> ( exp ) .)
    IDENTIFIER      reduce using rule 58 (prefixexp -> ( exp ) .)
    $end            reduce using rule 58 (prefixexp -> ( exp ) .)
    END             reduce using rule 58 (prefixexp -> ( exp ) .)
    UNTIL           reduce using rule 58 (prefixexp -> ( exp ) .)
    ELSEIF          reduce using rule 58 (prefixexp -> ( exp ) .)
    ELSE            reduce using rule 58 (prefixexp -> ( exp ) .)
    CIRCUMFLEX      reduce using rule 58 (prefixexp -> ( exp ) .)
    TIMES           reduce using rule 58 (prefixexp -> ( exp ) .)
    DIVIDE          reduce using rule 58 (prefixexp -> ( exp ) .)
    %               reduce using rule 58 (prefixexp -> ( exp ) .)
    PLUS            reduce using rule 58 (prefixexp -> ( exp ) .)
    MINUS           reduce using rule 58 (prefixexp -> ( exp ) .)
    CONCAT          reduce using rule 58 (prefixexp -> ( exp ) .)
    LT              reduce using rule 58 (prefixexp -> ( exp ) .)
    LTE             reduce using rule 58 (prefixexp -> ( exp ) .)
    GT              reduce using rule 58 (prefixexp -> ( exp ) .)
    GTE             reduce using rule 58 (prefixexp -> ( exp ) .)
    NE              reduce using rule 58 (prefixexp -> ( exp ) .)
    EQUALS          reduce using rule 58 (prefixexp -> ( exp ) .)
    AND             reduce using rule 58 (prefixexp -> ( exp ) .)
    OR              reduce using rule 58 (prefixexp -> ( exp ) .)
    THEN            reduce using rule 58 (prefixexp -> ( exp ) .)
    )               reduce using rule 58 (prefixexp -> ( exp ) .)
    }               reduce using rule 58 (prefixexp -> ( exp ) .)
    RETURN          reduce using rule 58 (prefixexp -> ( exp ) .)
    BREAK           reduce using rule 58 (prefixexp -> ( exp ) .)
    ]               reduce using rule 58 (prefixexp -> ( exp ) .)


state 142

    (55) explist -> explist , exp .
    (112) op_9 -> exp .

  ! reduce/reduce conflict for , resolved using rule 55 (explist -> explist , exp .)
  ! reduce/reduce conflict for ; resolved using rule 55 (explist -> explist , exp .)
  ! reduce/reduce conflict for LOCAL resolved using rule 55 (explist -> explist , exp .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 55 (explist -> explist , exp .)
  ! reduce/reduce conflict for DO resolved using rule 55 (explist -> explist , exp .)
  ! reduce/reduce conflict for WHILE resolved using rule 55 (explist -> explist , exp .)
  ! reduce/reduce conflict for REPEAT resolved using rule 55 (explist -> explist , exp .)
  ! reduce/reduce conflict for FOR resolved using rule 55 (explist -> explist , exp .)
  ! reduce/reduce conflict for IF resolved using rule 55 (explist -> explist , exp .)
  ! reduce/reduce conflict for ( resolved using rule 55 (explist -> explist , exp .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 55 (explist -> explist , exp .)
  ! reduce/reduce conflict for $end resolved using rule 55 (explist -> explist , exp .)
  ! reduce/reduce conflict for END resolved using rule 55 (explist -> explist , exp .)
  ! reduce/reduce conflict for UNTIL resolved using rule 55 (explist -> explist , exp .)
  ! reduce/reduce conflict for ELSEIF resolved using rule 55 (explist -> explist , exp .)
  ! reduce/reduce conflict for ELSE resolved using rule 55 (explist -> explist , exp .)
  ! reduce/reduce conflict for RETURN resolved using rule 55 (explist -> explist , exp .)
  ! reduce/reduce conflict for BREAK resolved using rule 55 (explist -> explist , exp .)
  ! reduce/reduce conflict for ) resolved using rule 55 (explist -> explist , exp .)
    ,               reduce using rule 55 (explist -> explist , exp .)
    ;               reduce using rule 55 (explist -> explist , exp .)
    LOCAL           reduce using rule 55 (explist -> explist , exp .)
    FUNCTION        reduce using rule 55 (explist -> explist , exp .)
    DO              reduce using rule 55 (explist -> explist , exp .)
    WHILE           reduce using rule 55 (explist -> explist , exp .)
    REPEAT          reduce using rule 55 (explist -> explist , exp .)
    FOR             reduce using rule 55 (explist -> explist , exp .)
    IF              reduce using rule 55 (explist -> explist , exp .)
    (               reduce using rule 55 (explist -> explist , exp .)
    IDENTIFIER      reduce using rule 55 (explist -> explist , exp .)
    $end            reduce using rule 55 (explist -> explist , exp .)
    END             reduce using rule 55 (explist -> explist , exp .)
    UNTIL           reduce using rule 55 (explist -> explist , exp .)
    ELSEIF          reduce using rule 55 (explist -> explist , exp .)
    ELSE            reduce using rule 55 (explist -> explist , exp .)
    RETURN          reduce using rule 55 (explist -> explist , exp .)
    BREAK           reduce using rule 55 (explist -> explist , exp .)
    )               reduce using rule 55 (explist -> explist , exp .)
    TIMES           reduce using rule 112 (op_9 -> exp .)
    DIVIDE          reduce using rule 112 (op_9 -> exp .)
    %               reduce using rule 112 (op_9 -> exp .)
    PLUS            reduce using rule 112 (op_9 -> exp .)
    MINUS           reduce using rule 112 (op_9 -> exp .)
    CONCAT          reduce using rule 112 (op_9 -> exp .)
    LT              reduce using rule 112 (op_9 -> exp .)
    LTE             reduce using rule 112 (op_9 -> exp .)
    GT              reduce using rule 112 (op_9 -> exp .)
    GTE             reduce using rule 112 (op_9 -> exp .)
    NE              reduce using rule 112 (op_9 -> exp .)
    EQUALS          reduce using rule 112 (op_9 -> exp .)
    AND             reduce using rule 112 (op_9 -> exp .)
    OR              reduce using rule 112 (op_9 -> exp .)
    CIRCUMFLEX      reduce using rule 112 (op_9 -> exp .)

  ! ,               [ reduce using rule 112 (op_9 -> exp .) ]
  ! ;               [ reduce using rule 112 (op_9 -> exp .) ]
  ! LOCAL           [ reduce using rule 112 (op_9 -> exp .) ]
  ! FUNCTION        [ reduce using rule 112 (op_9 -> exp .) ]
  ! DO              [ reduce using rule 112 (op_9 -> exp .) ]
  ! WHILE           [ reduce using rule 112 (op_9 -> exp .) ]
  ! REPEAT          [ reduce using rule 112 (op_9 -> exp .) ]
  ! FOR             [ reduce using rule 112 (op_9 -> exp .) ]
  ! IF              [ reduce using rule 112 (op_9 -> exp .) ]
  ! (               [ reduce using rule 112 (op_9 -> exp .) ]
  ! IDENTIFIER      [ reduce using rule 112 (op_9 -> exp .) ]
  ! $end            [ reduce using rule 112 (op_9 -> exp .) ]
  ! END             [ reduce using rule 112 (op_9 -> exp .) ]
  ! UNTIL           [ reduce using rule 112 (op_9 -> exp .) ]
  ! ELSEIF          [ reduce using rule 112 (op_9 -> exp .) ]
  ! ELSE            [ reduce using rule 112 (op_9 -> exp .) ]
  ! RETURN          [ reduce using rule 112 (op_9 -> exp .) ]
  ! BREAK           [ reduce using rule 112 (op_9 -> exp .) ]
  ! )               [ reduce using rule 112 (op_9 -> exp .) ]


state 143

    (63) funcbody -> ( parlist . ) block END

    )               shift and go to state 186


state 144

    (64) funcbody -> ( ) . block END
    (1) block -> . chunk
    (2) chunk -> . chunk2 laststat
    (3) chunk -> . chunk2
    (4) chunk -> . laststat
    (5) chunk2 -> . stat optsemi
    (6) chunk2 -> . chunk stat optsemi
    (9) laststat -> . RETURN explist optsemi
    (10) laststat -> . RETURN optsemi
    (11) laststat -> . BREAK optsemi
    (12) stat -> . varlist = explist
    (13) stat -> . LOCAL namelist = explist
    (14) stat -> . LOCAL namelist
    (15) stat -> . FUNCTION funcname funcbody
    (16) stat -> . LOCAL FUNCTION name funcbody
    (17) stat -> . functioncall
    (18) stat -> . DO block END
    (19) stat -> . WHILE exp DO block END
    (20) stat -> . REPEAT block UNTIL exp
    (21) stat -> . if elseiflist else END
    (22) stat -> . FOR name = exp , exp DO block END
    (23) stat -> . FOR name = exp , exp , exp DO block END
    (24) stat -> . FOR namelist IN explist DO block END
    (35) varlist -> . var
    (36) varlist -> . varlist , var
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (25) if -> . IF exp THEN block
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (37) name -> . IDENTIFIER

    RETURN          shift and go to state 6
    BREAK           shift and go to state 7
    LOCAL           shift and go to state 9
    FUNCTION        shift and go to state 10
    DO              shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    FOR             shift and go to state 17
    IF              shift and go to state 20
    (               shift and go to state 21
    IDENTIFIER      shift and go to state 22

    block                          shift and go to state 187
    chunk                          shift and go to state 2
    chunk2                         shift and go to state 3
    laststat                       shift and go to state 4
    stat                           shift and go to state 5
    varlist                        shift and go to state 8
    name                           shift and go to state 11
    functioncall                   shift and go to state 12
    if                             shift and go to state 16
    var                            shift and go to state 18
    prefixexp                      shift and go to state 19

state 145

    (65) parlist -> namelist .
    (66) parlist -> namelist . , TDOT
    (43) namelist -> namelist . , name

    )               reduce using rule 65 (parlist -> namelist .)
    ,               shift and go to state 188


state 146

    (67) parlist -> TDOT .

    )               reduce using rule 67 (parlist -> TDOT .)


state 147

    (72) tableconstructor -> { fieldlist } .

    ,               reduce using rule 72 (tableconstructor -> { fieldlist } .)
    ;               reduce using rule 72 (tableconstructor -> { fieldlist } .)
    LOCAL           reduce using rule 72 (tableconstructor -> { fieldlist } .)
    FUNCTION        reduce using rule 72 (tableconstructor -> { fieldlist } .)
    DO              reduce using rule 72 (tableconstructor -> { fieldlist } .)
    WHILE           reduce using rule 72 (tableconstructor -> { fieldlist } .)
    REPEAT          reduce using rule 72 (tableconstructor -> { fieldlist } .)
    FOR             reduce using rule 72 (tableconstructor -> { fieldlist } .)
    IF              reduce using rule 72 (tableconstructor -> { fieldlist } .)
    (               reduce using rule 72 (tableconstructor -> { fieldlist } .)
    IDENTIFIER      reduce using rule 72 (tableconstructor -> { fieldlist } .)
    $end            reduce using rule 72 (tableconstructor -> { fieldlist } .)
    END             reduce using rule 72 (tableconstructor -> { fieldlist } .)
    UNTIL           reduce using rule 72 (tableconstructor -> { fieldlist } .)
    ELSEIF          reduce using rule 72 (tableconstructor -> { fieldlist } .)
    ELSE            reduce using rule 72 (tableconstructor -> { fieldlist } .)
    CIRCUMFLEX      reduce using rule 72 (tableconstructor -> { fieldlist } .)
    TIMES           reduce using rule 72 (tableconstructor -> { fieldlist } .)
    DIVIDE          reduce using rule 72 (tableconstructor -> { fieldlist } .)
    %               reduce using rule 72 (tableconstructor -> { fieldlist } .)
    PLUS            reduce using rule 72 (tableconstructor -> { fieldlist } .)
    MINUS           reduce using rule 72 (tableconstructor -> { fieldlist } .)
    CONCAT          reduce using rule 72 (tableconstructor -> { fieldlist } .)
    LT              reduce using rule 72 (tableconstructor -> { fieldlist } .)
    LTE             reduce using rule 72 (tableconstructor -> { fieldlist } .)
    GT              reduce using rule 72 (tableconstructor -> { fieldlist } .)
    GTE             reduce using rule 72 (tableconstructor -> { fieldlist } .)
    NE              reduce using rule 72 (tableconstructor -> { fieldlist } .)
    EQUALS          reduce using rule 72 (tableconstructor -> { fieldlist } .)
    AND             reduce using rule 72 (tableconstructor -> { fieldlist } .)
    OR              reduce using rule 72 (tableconstructor -> { fieldlist } .)
    RETURN          reduce using rule 72 (tableconstructor -> { fieldlist } .)
    BREAK           reduce using rule 72 (tableconstructor -> { fieldlist } .)
    :               reduce using rule 72 (tableconstructor -> { fieldlist } .)
    [               reduce using rule 72 (tableconstructor -> { fieldlist } .)
    .               reduce using rule 72 (tableconstructor -> { fieldlist } .)
    {               reduce using rule 72 (tableconstructor -> { fieldlist } .)
    STRING          reduce using rule 72 (tableconstructor -> { fieldlist } .)
    THEN            reduce using rule 72 (tableconstructor -> { fieldlist } .)
    )               reduce using rule 72 (tableconstructor -> { fieldlist } .)
    }               reduce using rule 72 (tableconstructor -> { fieldlist } .)
    ]               reduce using rule 72 (tableconstructor -> { fieldlist } .)


state 148

    (77) fieldlist -> fieldlist2 optfieldsep .

    }               reduce using rule 77 (fieldlist -> fieldlist2 optfieldsep .)


state 149

    (79) fieldlist2 -> fieldlist2 fieldsep . field
    (80) optfieldsep -> fieldsep .
    (74) field -> . [ exp ] = exp
    (75) field -> . name = exp
    (76) field -> . exp
    (37) name -> . IDENTIFIER
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp

    }               reduce using rule 80 (optfieldsep -> fieldsep .)
    [               shift and go to state 94
    IDENTIFIER      shift and go to state 22
    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    field                          shift and go to state 189
    exp                            shift and go to state 95
    name                           shift and go to state 96
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57

state 150

    (81) optfieldsep -> empty .

    }               reduce using rule 81 (optfieldsep -> empty .)


state 151

    (82) fieldsep -> , .

    [               reduce using rule 82 (fieldsep -> , .)
    IDENTIFIER      reduce using rule 82 (fieldsep -> , .)
    NIL             reduce using rule 82 (fieldsep -> , .)
    FALSE           reduce using rule 82 (fieldsep -> , .)
    TRUE            reduce using rule 82 (fieldsep -> , .)
    NUMBER          reduce using rule 82 (fieldsep -> , .)
    TDOT            reduce using rule 82 (fieldsep -> , .)
    STRING          reduce using rule 82 (fieldsep -> , .)
    FUNCTION        reduce using rule 82 (fieldsep -> , .)
    (               reduce using rule 82 (fieldsep -> , .)
    {               reduce using rule 82 (fieldsep -> , .)
    NOT             reduce using rule 82 (fieldsep -> , .)
    HASH            reduce using rule 82 (fieldsep -> , .)
    MINUS           reduce using rule 82 (fieldsep -> , .)
    }               reduce using rule 82 (fieldsep -> , .)


state 152

    (83) fieldsep -> ; .

    [               reduce using rule 83 (fieldsep -> ; .)
    IDENTIFIER      reduce using rule 83 (fieldsep -> ; .)
    NIL             reduce using rule 83 (fieldsep -> ; .)
    FALSE           reduce using rule 83 (fieldsep -> ; .)
    TRUE            reduce using rule 83 (fieldsep -> ; .)
    NUMBER          reduce using rule 83 (fieldsep -> ; .)
    TDOT            reduce using rule 83 (fieldsep -> ; .)
    STRING          reduce using rule 83 (fieldsep -> ; .)
    FUNCTION        reduce using rule 83 (fieldsep -> ; .)
    (               reduce using rule 83 (fieldsep -> ; .)
    {               reduce using rule 83 (fieldsep -> ; .)
    NOT             reduce using rule 83 (fieldsep -> ; .)
    HASH            reduce using rule 83 (fieldsep -> ; .)
    MINUS           reduce using rule 83 (fieldsep -> ; .)
    }               reduce using rule 83 (fieldsep -> ; .)


state 153

    (74) field -> [ exp . ] = exp
    (112) op_9 -> exp .

  ! shift/reduce conflict for ] resolved as shift
    ]               shift and go to state 190
    TIMES           reduce using rule 112 (op_9 -> exp .)
    DIVIDE          reduce using rule 112 (op_9 -> exp .)
    %               reduce using rule 112 (op_9 -> exp .)
    PLUS            reduce using rule 112 (op_9 -> exp .)
    MINUS           reduce using rule 112 (op_9 -> exp .)
    CONCAT          reduce using rule 112 (op_9 -> exp .)
    LT              reduce using rule 112 (op_9 -> exp .)
    LTE             reduce using rule 112 (op_9 -> exp .)
    GT              reduce using rule 112 (op_9 -> exp .)
    GTE             reduce using rule 112 (op_9 -> exp .)
    NE              reduce using rule 112 (op_9 -> exp .)
    EQUALS          reduce using rule 112 (op_9 -> exp .)
    AND             reduce using rule 112 (op_9 -> exp .)
    OR              reduce using rule 112 (op_9 -> exp .)
    CIRCUMFLEX      reduce using rule 112 (op_9 -> exp .)

  ! ]               [ reduce using rule 112 (op_9 -> exp .) ]


state 154

    (75) field -> name = . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp

    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    name                           shift and go to state 11
    exp                            shift and go to state 191
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57

state 155

    (86) op_1 -> op_1 OR op_2 .
    (88) op_2 -> op_2 . AND op_3
    (87) op_1 -> op_2 .

  ! shift/reduce conflict for AND resolved as shift
  ! reduce/reduce conflict for CIRCUMFLEX resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for , resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for ; resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for LOCAL resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for DO resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for WHILE resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for REPEAT resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for FOR resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for IF resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for ( resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for $end resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for END resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for UNTIL resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for ELSEIF resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for ELSE resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for TIMES resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for % resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for PLUS resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for MINUS resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for CONCAT resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for LT resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for LTE resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for GT resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for GTE resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for NE resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for EQUALS resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! shift/reduce conflict for AND resolved as shift
  ! reduce/reduce conflict for OR resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for THEN resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for ) resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for } resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for RETURN resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for BREAK resolved using rule 86 (op_1 -> op_1 OR op_2 .)
  ! reduce/reduce conflict for ] resolved using rule 86 (op_1 -> op_1 OR op_2 .)
    ,               reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    ;               reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    LOCAL           reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    FUNCTION        reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    DO              reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    WHILE           reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    REPEAT          reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    FOR             reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    IF              reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    (               reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    IDENTIFIER      reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    $end            reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    END             reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    UNTIL           reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    ELSEIF          reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    ELSE            reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    CIRCUMFLEX      reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    TIMES           reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    DIVIDE          reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    %               reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    PLUS            reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    MINUS           reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    CONCAT          reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    LT              reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    LTE             reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    GT              reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    GTE             reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    NE              reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    EQUALS          reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    OR              reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    THEN            reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    )               reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    }               reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    RETURN          reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    BREAK           reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    ]               reduce using rule 86 (op_1 -> op_1 OR op_2 .)
    AND             shift and go to state 98

  ! AND             [ reduce using rule 86 (op_1 -> op_1 OR op_2 .) ]
  ! CIRCUMFLEX      [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! ,               [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! ;               [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! LOCAL           [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! FUNCTION        [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! DO              [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! WHILE           [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! REPEAT          [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! FOR             [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! IF              [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! (               [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! IDENTIFIER      [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! $end            [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! END             [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! UNTIL           [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! ELSEIF          [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! ELSE            [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! TIMES           [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! DIVIDE          [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! %               [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! PLUS            [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! MINUS           [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! CONCAT          [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! LT              [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! LTE             [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! GT              [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! GTE             [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! NE              [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! EQUALS          [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! AND             [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! OR              [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! THEN            [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! )               [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! }               [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! RETURN          [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! BREAK           [ reduce using rule 87 (op_1 -> op_2 .) ]
  ! ]               [ reduce using rule 87 (op_1 -> op_2 .) ]


state 156

    (88) op_2 -> op_2 AND op_3 .
    (90) op_3 -> op_3 . LT op_4
    (91) op_3 -> op_3 . LTE op_4
    (92) op_3 -> op_3 . GT op_4
    (93) op_3 -> op_3 . GTE op_4
    (94) op_3 -> op_3 . NE op_4
    (95) op_3 -> op_3 . EQUALS op_4
    (89) op_2 -> op_3 .

  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! reduce/reduce conflict for CIRCUMFLEX resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for , resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for ; resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for LOCAL resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for DO resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for WHILE resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for REPEAT resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for FOR resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for IF resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for ( resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for $end resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for END resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for UNTIL resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for ELSEIF resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for ELSE resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for TIMES resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for % resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for PLUS resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for MINUS resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for CONCAT resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! reduce/reduce conflict for AND resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for OR resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for THEN resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for ) resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for } resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for RETURN resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for BREAK resolved using rule 88 (op_2 -> op_2 AND op_3 .)
  ! reduce/reduce conflict for ] resolved using rule 88 (op_2 -> op_2 AND op_3 .)
    ,               reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    ;               reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    LOCAL           reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    FUNCTION        reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    DO              reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    WHILE           reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    REPEAT          reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    FOR             reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    IF              reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    (               reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    IDENTIFIER      reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    $end            reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    END             reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    UNTIL           reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    ELSEIF          reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    ELSE            reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    CIRCUMFLEX      reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    TIMES           reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    DIVIDE          reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    %               reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    PLUS            reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    MINUS           reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    CONCAT          reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    AND             reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    OR              reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    THEN            reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    )               reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    }               reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    RETURN          reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    BREAK           reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    ]               reduce using rule 88 (op_2 -> op_2 AND op_3 .)
    LT              shift and go to state 99
    LTE             shift and go to state 100
    GT              shift and go to state 101
    GTE             shift and go to state 102
    NE              shift and go to state 103
    EQUALS          shift and go to state 104

  ! LT              [ reduce using rule 88 (op_2 -> op_2 AND op_3 .) ]
  ! LTE             [ reduce using rule 88 (op_2 -> op_2 AND op_3 .) ]
  ! GT              [ reduce using rule 88 (op_2 -> op_2 AND op_3 .) ]
  ! GTE             [ reduce using rule 88 (op_2 -> op_2 AND op_3 .) ]
  ! NE              [ reduce using rule 88 (op_2 -> op_2 AND op_3 .) ]
  ! EQUALS          [ reduce using rule 88 (op_2 -> op_2 AND op_3 .) ]
  ! CIRCUMFLEX      [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! ,               [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! ;               [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! LOCAL           [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! FUNCTION        [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! DO              [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! WHILE           [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! REPEAT          [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! FOR             [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! IF              [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! (               [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! IDENTIFIER      [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! $end            [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! END             [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! UNTIL           [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! ELSEIF          [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! ELSE            [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! TIMES           [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! DIVIDE          [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! %               [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! PLUS            [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! MINUS           [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! CONCAT          [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! LT              [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! LTE             [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! GT              [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! GTE             [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! NE              [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! EQUALS          [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! AND             [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! OR              [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! THEN            [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! )               [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! }               [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! RETURN          [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! BREAK           [ reduce using rule 89 (op_2 -> op_3 .) ]
  ! ]               [ reduce using rule 89 (op_2 -> op_3 .) ]


state 157

    (90) op_3 -> op_3 LT op_4 .
    (97) op_4 -> op_4 . CONCAT op_5
    (96) op_3 -> op_4 .

  ! shift/reduce conflict for CONCAT resolved as shift
  ! reduce/reduce conflict for CIRCUMFLEX resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for , resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for ; resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for LOCAL resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for DO resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for WHILE resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for REPEAT resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for FOR resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for IF resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for ( resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for $end resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for END resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for UNTIL resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for ELSEIF resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for ELSE resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for TIMES resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for % resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for PLUS resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for MINUS resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! shift/reduce conflict for CONCAT resolved as shift
  ! reduce/reduce conflict for LT resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for LTE resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for GT resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for GTE resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for NE resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for EQUALS resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for AND resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for OR resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for THEN resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for ) resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for } resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for RETURN resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for BREAK resolved using rule 90 (op_3 -> op_3 LT op_4 .)
  ! reduce/reduce conflict for ] resolved using rule 90 (op_3 -> op_3 LT op_4 .)
    ,               reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    ;               reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    LOCAL           reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    FUNCTION        reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    DO              reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    WHILE           reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    REPEAT          reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    FOR             reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    IF              reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    (               reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    IDENTIFIER      reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    $end            reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    END             reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    UNTIL           reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    ELSEIF          reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    ELSE            reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    CIRCUMFLEX      reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    TIMES           reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    DIVIDE          reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    %               reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    PLUS            reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    MINUS           reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    LT              reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    LTE             reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    GT              reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    GTE             reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    NE              reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    EQUALS          reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    AND             reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    OR              reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    THEN            reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    )               reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    }               reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    RETURN          reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    BREAK           reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    ]               reduce using rule 90 (op_3 -> op_3 LT op_4 .)
    CONCAT          shift and go to state 105

  ! CONCAT          [ reduce using rule 90 (op_3 -> op_3 LT op_4 .) ]
  ! CIRCUMFLEX      [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ,               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ;               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! LOCAL           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! FUNCTION        [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! DO              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! WHILE           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! REPEAT          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! FOR             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! IF              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! (               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! IDENTIFIER      [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! $end            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! END             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! UNTIL           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ELSEIF          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ELSE            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! TIMES           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! DIVIDE          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! %               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! PLUS            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! MINUS           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! CONCAT          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! LT              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! LTE             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! GT              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! GTE             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! NE              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! EQUALS          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! AND             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! OR              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! THEN            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! )               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! }               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! RETURN          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! BREAK           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ]               [ reduce using rule 96 (op_3 -> op_4 .) ]


state 158

    (91) op_3 -> op_3 LTE op_4 .
    (97) op_4 -> op_4 . CONCAT op_5
    (96) op_3 -> op_4 .

  ! shift/reduce conflict for CONCAT resolved as shift
  ! reduce/reduce conflict for CIRCUMFLEX resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for , resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for ; resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for LOCAL resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for DO resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for WHILE resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for REPEAT resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for FOR resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for IF resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for ( resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for $end resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for END resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for UNTIL resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for ELSEIF resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for ELSE resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for TIMES resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for % resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for PLUS resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for MINUS resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! shift/reduce conflict for CONCAT resolved as shift
  ! reduce/reduce conflict for LT resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for LTE resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for GT resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for GTE resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for NE resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for EQUALS resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for AND resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for OR resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for THEN resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for ) resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for } resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for RETURN resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for BREAK resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
  ! reduce/reduce conflict for ] resolved using rule 91 (op_3 -> op_3 LTE op_4 .)
    ,               reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    ;               reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    LOCAL           reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    FUNCTION        reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    DO              reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    WHILE           reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    REPEAT          reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    FOR             reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    IF              reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    (               reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    IDENTIFIER      reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    $end            reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    END             reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    UNTIL           reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    ELSEIF          reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    ELSE            reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    CIRCUMFLEX      reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    TIMES           reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    DIVIDE          reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    %               reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    PLUS            reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    MINUS           reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    LT              reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    LTE             reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    GT              reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    GTE             reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    NE              reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    EQUALS          reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    AND             reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    OR              reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    THEN            reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    )               reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    }               reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    RETURN          reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    BREAK           reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    ]               reduce using rule 91 (op_3 -> op_3 LTE op_4 .)
    CONCAT          shift and go to state 105

  ! CONCAT          [ reduce using rule 91 (op_3 -> op_3 LTE op_4 .) ]
  ! CIRCUMFLEX      [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ,               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ;               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! LOCAL           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! FUNCTION        [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! DO              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! WHILE           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! REPEAT          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! FOR             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! IF              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! (               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! IDENTIFIER      [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! $end            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! END             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! UNTIL           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ELSEIF          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ELSE            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! TIMES           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! DIVIDE          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! %               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! PLUS            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! MINUS           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! CONCAT          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! LT              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! LTE             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! GT              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! GTE             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! NE              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! EQUALS          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! AND             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! OR              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! THEN            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! )               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! }               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! RETURN          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! BREAK           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ]               [ reduce using rule 96 (op_3 -> op_4 .) ]


state 159

    (92) op_3 -> op_3 GT op_4 .
    (97) op_4 -> op_4 . CONCAT op_5
    (96) op_3 -> op_4 .

  ! shift/reduce conflict for CONCAT resolved as shift
  ! reduce/reduce conflict for CIRCUMFLEX resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for , resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for ; resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for LOCAL resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for DO resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for WHILE resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for REPEAT resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for FOR resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for IF resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for ( resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for $end resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for END resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for UNTIL resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for ELSEIF resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for ELSE resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for TIMES resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for % resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for PLUS resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for MINUS resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! shift/reduce conflict for CONCAT resolved as shift
  ! reduce/reduce conflict for LT resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for LTE resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for GT resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for GTE resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for NE resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for EQUALS resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for AND resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for OR resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for THEN resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for ) resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for } resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for RETURN resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for BREAK resolved using rule 92 (op_3 -> op_3 GT op_4 .)
  ! reduce/reduce conflict for ] resolved using rule 92 (op_3 -> op_3 GT op_4 .)
    ,               reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    ;               reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    LOCAL           reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    FUNCTION        reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    DO              reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    WHILE           reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    REPEAT          reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    FOR             reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    IF              reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    (               reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    IDENTIFIER      reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    $end            reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    END             reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    UNTIL           reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    ELSEIF          reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    ELSE            reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    CIRCUMFLEX      reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    TIMES           reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    DIVIDE          reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    %               reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    PLUS            reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    MINUS           reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    LT              reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    LTE             reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    GT              reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    GTE             reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    NE              reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    EQUALS          reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    AND             reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    OR              reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    THEN            reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    )               reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    }               reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    RETURN          reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    BREAK           reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    ]               reduce using rule 92 (op_3 -> op_3 GT op_4 .)
    CONCAT          shift and go to state 105

  ! CONCAT          [ reduce using rule 92 (op_3 -> op_3 GT op_4 .) ]
  ! CIRCUMFLEX      [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ,               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ;               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! LOCAL           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! FUNCTION        [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! DO              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! WHILE           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! REPEAT          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! FOR             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! IF              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! (               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! IDENTIFIER      [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! $end            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! END             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! UNTIL           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ELSEIF          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ELSE            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! TIMES           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! DIVIDE          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! %               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! PLUS            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! MINUS           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! CONCAT          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! LT              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! LTE             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! GT              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! GTE             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! NE              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! EQUALS          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! AND             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! OR              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! THEN            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! )               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! }               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! RETURN          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! BREAK           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ]               [ reduce using rule 96 (op_3 -> op_4 .) ]


state 160

    (93) op_3 -> op_3 GTE op_4 .
    (97) op_4 -> op_4 . CONCAT op_5
    (96) op_3 -> op_4 .

  ! shift/reduce conflict for CONCAT resolved as shift
  ! reduce/reduce conflict for CIRCUMFLEX resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for , resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for ; resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for LOCAL resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for DO resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for WHILE resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for REPEAT resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for FOR resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for IF resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for ( resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for $end resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for END resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for UNTIL resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for ELSEIF resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for ELSE resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for TIMES resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for % resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for PLUS resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for MINUS resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! shift/reduce conflict for CONCAT resolved as shift
  ! reduce/reduce conflict for LT resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for LTE resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for GT resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for GTE resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for NE resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for EQUALS resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for AND resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for OR resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for THEN resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for ) resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for } resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for RETURN resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for BREAK resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
  ! reduce/reduce conflict for ] resolved using rule 93 (op_3 -> op_3 GTE op_4 .)
    ,               reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    ;               reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    LOCAL           reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    FUNCTION        reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    DO              reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    WHILE           reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    REPEAT          reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    FOR             reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    IF              reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    (               reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    IDENTIFIER      reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    $end            reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    END             reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    UNTIL           reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    ELSEIF          reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    ELSE            reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    CIRCUMFLEX      reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    TIMES           reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    DIVIDE          reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    %               reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    PLUS            reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    MINUS           reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    LT              reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    LTE             reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    GT              reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    GTE             reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    NE              reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    EQUALS          reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    AND             reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    OR              reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    THEN            reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    )               reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    }               reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    RETURN          reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    BREAK           reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    ]               reduce using rule 93 (op_3 -> op_3 GTE op_4 .)
    CONCAT          shift and go to state 105

  ! CONCAT          [ reduce using rule 93 (op_3 -> op_3 GTE op_4 .) ]
  ! CIRCUMFLEX      [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ,               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ;               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! LOCAL           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! FUNCTION        [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! DO              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! WHILE           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! REPEAT          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! FOR             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! IF              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! (               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! IDENTIFIER      [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! $end            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! END             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! UNTIL           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ELSEIF          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ELSE            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! TIMES           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! DIVIDE          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! %               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! PLUS            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! MINUS           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! CONCAT          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! LT              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! LTE             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! GT              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! GTE             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! NE              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! EQUALS          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! AND             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! OR              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! THEN            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! )               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! }               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! RETURN          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! BREAK           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ]               [ reduce using rule 96 (op_3 -> op_4 .) ]


state 161

    (94) op_3 -> op_3 NE op_4 .
    (97) op_4 -> op_4 . CONCAT op_5
    (96) op_3 -> op_4 .

  ! shift/reduce conflict for CONCAT resolved as shift
  ! reduce/reduce conflict for CIRCUMFLEX resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for , resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for ; resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for LOCAL resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for DO resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for WHILE resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for REPEAT resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for FOR resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for IF resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for ( resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for $end resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for END resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for UNTIL resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for ELSEIF resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for ELSE resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for TIMES resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for % resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for PLUS resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for MINUS resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! shift/reduce conflict for CONCAT resolved as shift
  ! reduce/reduce conflict for LT resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for LTE resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for GT resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for GTE resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for NE resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for EQUALS resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for AND resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for OR resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for THEN resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for ) resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for } resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for RETURN resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for BREAK resolved using rule 94 (op_3 -> op_3 NE op_4 .)
  ! reduce/reduce conflict for ] resolved using rule 94 (op_3 -> op_3 NE op_4 .)
    ,               reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    ;               reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    LOCAL           reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    FUNCTION        reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    DO              reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    WHILE           reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    REPEAT          reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    FOR             reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    IF              reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    (               reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    IDENTIFIER      reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    $end            reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    END             reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    UNTIL           reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    ELSEIF          reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    ELSE            reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    CIRCUMFLEX      reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    TIMES           reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    DIVIDE          reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    %               reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    PLUS            reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    MINUS           reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    LT              reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    LTE             reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    GT              reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    GTE             reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    NE              reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    EQUALS          reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    AND             reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    OR              reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    THEN            reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    )               reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    }               reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    RETURN          reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    BREAK           reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    ]               reduce using rule 94 (op_3 -> op_3 NE op_4 .)
    CONCAT          shift and go to state 105

  ! CONCAT          [ reduce using rule 94 (op_3 -> op_3 NE op_4 .) ]
  ! CIRCUMFLEX      [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ,               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ;               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! LOCAL           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! FUNCTION        [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! DO              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! WHILE           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! REPEAT          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! FOR             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! IF              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! (               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! IDENTIFIER      [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! $end            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! END             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! UNTIL           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ELSEIF          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ELSE            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! TIMES           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! DIVIDE          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! %               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! PLUS            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! MINUS           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! CONCAT          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! LT              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! LTE             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! GT              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! GTE             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! NE              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! EQUALS          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! AND             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! OR              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! THEN            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! )               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! }               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! RETURN          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! BREAK           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ]               [ reduce using rule 96 (op_3 -> op_4 .) ]


state 162

    (95) op_3 -> op_3 EQUALS op_4 .
    (97) op_4 -> op_4 . CONCAT op_5
    (96) op_3 -> op_4 .

  ! shift/reduce conflict for CONCAT resolved as shift
  ! reduce/reduce conflict for CIRCUMFLEX resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for , resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for ; resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for LOCAL resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for DO resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for WHILE resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for REPEAT resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for FOR resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for IF resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for ( resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for $end resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for END resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for UNTIL resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for ELSEIF resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for ELSE resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for TIMES resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for % resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for PLUS resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for MINUS resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! shift/reduce conflict for CONCAT resolved as shift
  ! reduce/reduce conflict for LT resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for LTE resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for GT resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for GTE resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for NE resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for EQUALS resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for AND resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for OR resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for THEN resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for ) resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for } resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for RETURN resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for BREAK resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
  ! reduce/reduce conflict for ] resolved using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    ,               reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    ;               reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    LOCAL           reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    FUNCTION        reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    DO              reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    WHILE           reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    REPEAT          reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    FOR             reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    IF              reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    (               reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    IDENTIFIER      reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    $end            reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    END             reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    UNTIL           reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    ELSEIF          reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    ELSE            reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    CIRCUMFLEX      reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    TIMES           reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    DIVIDE          reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    %               reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    PLUS            reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    MINUS           reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    LT              reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    LTE             reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    GT              reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    GTE             reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    NE              reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    EQUALS          reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    AND             reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    OR              reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    THEN            reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    )               reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    }               reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    RETURN          reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    BREAK           reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    ]               reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .)
    CONCAT          shift and go to state 105

  ! CONCAT          [ reduce using rule 95 (op_3 -> op_3 EQUALS op_4 .) ]
  ! CIRCUMFLEX      [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ,               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ;               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! LOCAL           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! FUNCTION        [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! DO              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! WHILE           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! REPEAT          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! FOR             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! IF              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! (               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! IDENTIFIER      [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! $end            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! END             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! UNTIL           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ELSEIF          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ELSE            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! TIMES           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! DIVIDE          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! %               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! PLUS            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! MINUS           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! CONCAT          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! LT              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! LTE             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! GT              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! GTE             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! NE              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! EQUALS          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! AND             [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! OR              [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! THEN            [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! )               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! }               [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! RETURN          [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! BREAK           [ reduce using rule 96 (op_3 -> op_4 .) ]
  ! ]               [ reduce using rule 96 (op_3 -> op_4 .) ]


state 163

    (97) op_4 -> op_4 CONCAT op_5 .
    (99) op_5 -> op_5 . PLUS op_6
    (100) op_5 -> op_5 . MINUS op_6
    (98) op_4 -> op_5 .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for CIRCUMFLEX resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for , resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for ; resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for LOCAL resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for DO resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for WHILE resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for REPEAT resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for FOR resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for IF resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for ( resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for $end resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for END resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for UNTIL resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for ELSEIF resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for ELSE resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for TIMES resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for % resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for CONCAT resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for LT resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for LTE resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for GT resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for GTE resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for NE resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for EQUALS resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for AND resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for OR resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for THEN resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for ) resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for } resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for RETURN resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for BREAK resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
  ! reduce/reduce conflict for ] resolved using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    ,               reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    ;               reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    LOCAL           reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    FUNCTION        reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    DO              reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    WHILE           reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    REPEAT          reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    FOR             reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    IF              reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    (               reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    IDENTIFIER      reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    $end            reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    END             reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    UNTIL           reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    ELSEIF          reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    ELSE            reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    CIRCUMFLEX      reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    TIMES           reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    DIVIDE          reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    %               reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    CONCAT          reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    LT              reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    LTE             reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    GT              reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    GTE             reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    NE              reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    EQUALS          reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    AND             reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    OR              reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    THEN            reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    )               reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    }               reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    RETURN          reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    BREAK           reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    ]               reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .)
    PLUS            shift and go to state 106
    MINUS           shift and go to state 107

  ! PLUS            [ reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .) ]
  ! MINUS           [ reduce using rule 97 (op_4 -> op_4 CONCAT op_5 .) ]
  ! CIRCUMFLEX      [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! ,               [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! ;               [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! LOCAL           [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! FUNCTION        [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! DO              [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! WHILE           [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! REPEAT          [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! FOR             [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! IF              [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! (               [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! IDENTIFIER      [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! $end            [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! END             [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! UNTIL           [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! ELSEIF          [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! ELSE            [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! TIMES           [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! DIVIDE          [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! %               [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! PLUS            [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! MINUS           [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! CONCAT          [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! LT              [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! LTE             [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! GT              [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! GTE             [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! NE              [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! EQUALS          [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! AND             [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! OR              [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! THEN            [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! )               [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! }               [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! RETURN          [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! BREAK           [ reduce using rule 98 (op_4 -> op_5 .) ]
  ! ]               [ reduce using rule 98 (op_4 -> op_5 .) ]


state 164

    (99) op_5 -> op_5 PLUS op_6 .
    (102) op_6 -> op_6 . TIMES op_7
    (103) op_6 -> op_6 . DIVIDE op_7
    (104) op_6 -> op_6 . % op_7
    (101) op_5 -> op_6 .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! reduce/reduce conflict for CIRCUMFLEX resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for , resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for ; resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for LOCAL resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for DO resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for WHILE resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for REPEAT resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for FOR resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for IF resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for ( resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for $end resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for END resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for UNTIL resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for ELSEIF resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for ELSE resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for MINUS resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for CONCAT resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for LT resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for LTE resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for GT resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for GTE resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for NE resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for EQUALS resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for AND resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for OR resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for THEN resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for ) resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for } resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for RETURN resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for BREAK resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
  ! reduce/reduce conflict for ] resolved using rule 99 (op_5 -> op_5 PLUS op_6 .)
    ,               reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    ;               reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    LOCAL           reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    FUNCTION        reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    DO              reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    WHILE           reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    REPEAT          reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    FOR             reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    IF              reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    (               reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    IDENTIFIER      reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    $end            reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    END             reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    UNTIL           reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    ELSEIF          reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    ELSE            reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    CIRCUMFLEX      reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    PLUS            reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    MINUS           reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    CONCAT          reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    LT              reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    LTE             reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    GT              reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    GTE             reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    NE              reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    EQUALS          reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    AND             reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    OR              reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    THEN            reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    )               reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    }               reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    RETURN          reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    BREAK           reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    ]               reduce using rule 99 (op_5 -> op_5 PLUS op_6 .)
    TIMES           shift and go to state 108
    DIVIDE          shift and go to state 109
    %               shift and go to state 110

  ! TIMES           [ reduce using rule 99 (op_5 -> op_5 PLUS op_6 .) ]
  ! DIVIDE          [ reduce using rule 99 (op_5 -> op_5 PLUS op_6 .) ]
  ! %               [ reduce using rule 99 (op_5 -> op_5 PLUS op_6 .) ]
  ! CIRCUMFLEX      [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! ,               [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! ;               [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! LOCAL           [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! FUNCTION        [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! DO              [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! WHILE           [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! REPEAT          [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! FOR             [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! IF              [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! (               [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! IDENTIFIER      [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! $end            [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! END             [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! UNTIL           [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! ELSEIF          [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! ELSE            [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! TIMES           [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! DIVIDE          [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! %               [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! PLUS            [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! MINUS           [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! CONCAT          [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! LT              [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! LTE             [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! GT              [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! GTE             [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! NE              [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! EQUALS          [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! AND             [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! OR              [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! THEN            [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! )               [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! }               [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! RETURN          [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! BREAK           [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! ]               [ reduce using rule 101 (op_5 -> op_6 .) ]


state 165

    (100) op_5 -> op_5 MINUS op_6 .
    (102) op_6 -> op_6 . TIMES op_7
    (103) op_6 -> op_6 . DIVIDE op_7
    (104) op_6 -> op_6 . % op_7
    (101) op_5 -> op_6 .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! reduce/reduce conflict for CIRCUMFLEX resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for , resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for ; resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for LOCAL resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for DO resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for WHILE resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for REPEAT resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for FOR resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for IF resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for ( resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for $end resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for END resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for UNTIL resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for ELSEIF resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for ELSE resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for MINUS resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for CONCAT resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for LT resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for LTE resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for GT resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for GTE resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for NE resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for EQUALS resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for AND resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for OR resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for THEN resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for ) resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for } resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for RETURN resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for BREAK resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
  ! reduce/reduce conflict for ] resolved using rule 100 (op_5 -> op_5 MINUS op_6 .)
    ,               reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    ;               reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    LOCAL           reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    FUNCTION        reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    DO              reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    WHILE           reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    REPEAT          reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    FOR             reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    IF              reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    (               reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    IDENTIFIER      reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    $end            reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    END             reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    UNTIL           reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    ELSEIF          reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    ELSE            reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    CIRCUMFLEX      reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    PLUS            reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    MINUS           reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    CONCAT          reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    LT              reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    LTE             reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    GT              reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    GTE             reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    NE              reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    EQUALS          reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    AND             reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    OR              reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    THEN            reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    )               reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    }               reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    RETURN          reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    BREAK           reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    ]               reduce using rule 100 (op_5 -> op_5 MINUS op_6 .)
    TIMES           shift and go to state 108
    DIVIDE          shift and go to state 109
    %               shift and go to state 110

  ! TIMES           [ reduce using rule 100 (op_5 -> op_5 MINUS op_6 .) ]
  ! DIVIDE          [ reduce using rule 100 (op_5 -> op_5 MINUS op_6 .) ]
  ! %               [ reduce using rule 100 (op_5 -> op_5 MINUS op_6 .) ]
  ! CIRCUMFLEX      [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! ,               [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! ;               [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! LOCAL           [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! FUNCTION        [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! DO              [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! WHILE           [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! REPEAT          [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! FOR             [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! IF              [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! (               [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! IDENTIFIER      [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! $end            [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! END             [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! UNTIL           [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! ELSEIF          [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! ELSE            [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! TIMES           [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! DIVIDE          [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! %               [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! PLUS            [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! MINUS           [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! CONCAT          [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! LT              [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! LTE             [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! GT              [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! GTE             [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! NE              [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! EQUALS          [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! AND             [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! OR              [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! THEN            [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! )               [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! }               [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! RETURN          [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! BREAK           [ reduce using rule 101 (op_5 -> op_6 .) ]
  ! ]               [ reduce using rule 101 (op_5 -> op_6 .) ]


state 166

    (102) op_6 -> op_6 TIMES op_7 .
    (105) op_6 -> op_7 .

  ! reduce/reduce conflict for CIRCUMFLEX resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for , resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for ; resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for LOCAL resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for DO resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for WHILE resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for REPEAT resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for FOR resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for IF resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for ( resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for $end resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for END resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for UNTIL resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for ELSEIF resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for ELSE resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for TIMES resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for % resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for PLUS resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for MINUS resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for CONCAT resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for LT resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for LTE resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for GT resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for GTE resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for NE resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for EQUALS resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for AND resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for OR resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for THEN resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for ) resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for } resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for RETURN resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for BREAK resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
  ! reduce/reduce conflict for ] resolved using rule 102 (op_6 -> op_6 TIMES op_7 .)
    ,               reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    ;               reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    LOCAL           reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    FUNCTION        reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    DO              reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    WHILE           reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    REPEAT          reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    FOR             reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    IF              reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    (               reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    IDENTIFIER      reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    $end            reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    END             reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    UNTIL           reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    ELSEIF          reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    ELSE            reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    CIRCUMFLEX      reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    TIMES           reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    DIVIDE          reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    %               reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    PLUS            reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    MINUS           reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    CONCAT          reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    LT              reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    LTE             reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    GT              reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    GTE             reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    NE              reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    EQUALS          reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    AND             reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    OR              reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    THEN            reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    )               reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    }               reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    RETURN          reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    BREAK           reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)
    ]               reduce using rule 102 (op_6 -> op_6 TIMES op_7 .)

  ! CIRCUMFLEX      [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! ,               [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! ;               [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! LOCAL           [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! FUNCTION        [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! DO              [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! WHILE           [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! REPEAT          [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! FOR             [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! IF              [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! (               [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! IDENTIFIER      [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! $end            [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! END             [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! UNTIL           [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! ELSEIF          [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! ELSE            [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! TIMES           [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! DIVIDE          [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! %               [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! PLUS            [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! MINUS           [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! CONCAT          [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! LT              [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! LTE             [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! GT              [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! GTE             [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! NE              [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! EQUALS          [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! AND             [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! OR              [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! THEN            [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! )               [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! }               [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! RETURN          [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! BREAK           [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! ]               [ reduce using rule 105 (op_6 -> op_7 .) ]


state 167

    (103) op_6 -> op_6 DIVIDE op_7 .
    (105) op_6 -> op_7 .

  ! reduce/reduce conflict for CIRCUMFLEX resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for , resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for ; resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for LOCAL resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for DO resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for WHILE resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for REPEAT resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for FOR resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for IF resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for ( resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for $end resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for END resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for UNTIL resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for ELSEIF resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for ELSE resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for TIMES resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for % resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for PLUS resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for MINUS resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for CONCAT resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for LT resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for LTE resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for GT resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for GTE resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for NE resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for EQUALS resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for AND resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for OR resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for THEN resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for ) resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for } resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for RETURN resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for BREAK resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
  ! reduce/reduce conflict for ] resolved using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    ,               reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    ;               reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    LOCAL           reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    FUNCTION        reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    DO              reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    WHILE           reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    REPEAT          reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    FOR             reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    IF              reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    (               reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    IDENTIFIER      reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    $end            reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    END             reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    UNTIL           reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    ELSEIF          reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    ELSE            reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    CIRCUMFLEX      reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    TIMES           reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    DIVIDE          reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    %               reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    PLUS            reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    MINUS           reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    CONCAT          reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    LT              reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    LTE             reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    GT              reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    GTE             reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    NE              reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    EQUALS          reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    AND             reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    OR              reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    THEN            reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    )               reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    }               reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    RETURN          reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    BREAK           reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)
    ]               reduce using rule 103 (op_6 -> op_6 DIVIDE op_7 .)

  ! CIRCUMFLEX      [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! ,               [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! ;               [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! LOCAL           [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! FUNCTION        [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! DO              [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! WHILE           [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! REPEAT          [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! FOR             [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! IF              [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! (               [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! IDENTIFIER      [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! $end            [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! END             [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! UNTIL           [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! ELSEIF          [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! ELSE            [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! TIMES           [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! DIVIDE          [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! %               [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! PLUS            [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! MINUS           [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! CONCAT          [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! LT              [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! LTE             [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! GT              [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! GTE             [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! NE              [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! EQUALS          [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! AND             [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! OR              [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! THEN            [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! )               [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! }               [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! RETURN          [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! BREAK           [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! ]               [ reduce using rule 105 (op_6 -> op_7 .) ]


state 168

    (104) op_6 -> op_6 % op_7 .
    (105) op_6 -> op_7 .

  ! reduce/reduce conflict for CIRCUMFLEX resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for , resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for ; resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for LOCAL resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for DO resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for WHILE resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for REPEAT resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for FOR resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for IF resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for ( resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for $end resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for END resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for UNTIL resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for ELSEIF resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for ELSE resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for TIMES resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for % resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for PLUS resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for MINUS resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for CONCAT resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for LT resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for LTE resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for GT resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for GTE resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for NE resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for EQUALS resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for AND resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for OR resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for THEN resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for ) resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for } resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for RETURN resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for BREAK resolved using rule 104 (op_6 -> op_6 % op_7 .)
  ! reduce/reduce conflict for ] resolved using rule 104 (op_6 -> op_6 % op_7 .)
    ,               reduce using rule 104 (op_6 -> op_6 % op_7 .)
    ;               reduce using rule 104 (op_6 -> op_6 % op_7 .)
    LOCAL           reduce using rule 104 (op_6 -> op_6 % op_7 .)
    FUNCTION        reduce using rule 104 (op_6 -> op_6 % op_7 .)
    DO              reduce using rule 104 (op_6 -> op_6 % op_7 .)
    WHILE           reduce using rule 104 (op_6 -> op_6 % op_7 .)
    REPEAT          reduce using rule 104 (op_6 -> op_6 % op_7 .)
    FOR             reduce using rule 104 (op_6 -> op_6 % op_7 .)
    IF              reduce using rule 104 (op_6 -> op_6 % op_7 .)
    (               reduce using rule 104 (op_6 -> op_6 % op_7 .)
    IDENTIFIER      reduce using rule 104 (op_6 -> op_6 % op_7 .)
    $end            reduce using rule 104 (op_6 -> op_6 % op_7 .)
    END             reduce using rule 104 (op_6 -> op_6 % op_7 .)
    UNTIL           reduce using rule 104 (op_6 -> op_6 % op_7 .)
    ELSEIF          reduce using rule 104 (op_6 -> op_6 % op_7 .)
    ELSE            reduce using rule 104 (op_6 -> op_6 % op_7 .)
    CIRCUMFLEX      reduce using rule 104 (op_6 -> op_6 % op_7 .)
    TIMES           reduce using rule 104 (op_6 -> op_6 % op_7 .)
    DIVIDE          reduce using rule 104 (op_6 -> op_6 % op_7 .)
    %               reduce using rule 104 (op_6 -> op_6 % op_7 .)
    PLUS            reduce using rule 104 (op_6 -> op_6 % op_7 .)
    MINUS           reduce using rule 104 (op_6 -> op_6 % op_7 .)
    CONCAT          reduce using rule 104 (op_6 -> op_6 % op_7 .)
    LT              reduce using rule 104 (op_6 -> op_6 % op_7 .)
    LTE             reduce using rule 104 (op_6 -> op_6 % op_7 .)
    GT              reduce using rule 104 (op_6 -> op_6 % op_7 .)
    GTE             reduce using rule 104 (op_6 -> op_6 % op_7 .)
    NE              reduce using rule 104 (op_6 -> op_6 % op_7 .)
    EQUALS          reduce using rule 104 (op_6 -> op_6 % op_7 .)
    AND             reduce using rule 104 (op_6 -> op_6 % op_7 .)
    OR              reduce using rule 104 (op_6 -> op_6 % op_7 .)
    THEN            reduce using rule 104 (op_6 -> op_6 % op_7 .)
    )               reduce using rule 104 (op_6 -> op_6 % op_7 .)
    }               reduce using rule 104 (op_6 -> op_6 % op_7 .)
    RETURN          reduce using rule 104 (op_6 -> op_6 % op_7 .)
    BREAK           reduce using rule 104 (op_6 -> op_6 % op_7 .)
    ]               reduce using rule 104 (op_6 -> op_6 % op_7 .)

  ! CIRCUMFLEX      [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! ,               [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! ;               [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! LOCAL           [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! FUNCTION        [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! DO              [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! WHILE           [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! REPEAT          [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! FOR             [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! IF              [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! (               [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! IDENTIFIER      [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! $end            [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! END             [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! UNTIL           [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! ELSEIF          [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! ELSE            [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! TIMES           [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! DIVIDE          [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! %               [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! PLUS            [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! MINUS           [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! CONCAT          [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! LT              [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! LTE             [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! GT              [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! GTE             [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! NE              [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! EQUALS          [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! AND             [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! OR              [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! THEN            [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! )               [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! }               [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! RETURN          [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! BREAK           [ reduce using rule 105 (op_6 -> op_7 .) ]
  ! ]               [ reduce using rule 105 (op_6 -> op_7 .) ]


state 169

    (110) op_8 -> op_8 CIRCUMFLEX op_9 .
    (111) op_8 -> op_9 .

  ! reduce/reduce conflict for CIRCUMFLEX resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for , resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for ; resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for LOCAL resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for DO resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for WHILE resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for REPEAT resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for FOR resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for IF resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for ( resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for $end resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for END resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for UNTIL resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for ELSEIF resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for ELSE resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for TIMES resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for % resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for PLUS resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for MINUS resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for CONCAT resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for LT resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for LTE resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for GT resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for GTE resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for NE resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for EQUALS resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for AND resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for OR resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for THEN resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for ) resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for } resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for RETURN resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for BREAK resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
  ! reduce/reduce conflict for ] resolved using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    ,               reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    ;               reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    LOCAL           reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    FUNCTION        reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    DO              reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    WHILE           reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    REPEAT          reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    FOR             reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    IF              reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    (               reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    IDENTIFIER      reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    $end            reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    END             reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    UNTIL           reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    ELSEIF          reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    ELSE            reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    CIRCUMFLEX      reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    TIMES           reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    DIVIDE          reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    %               reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    PLUS            reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    MINUS           reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    CONCAT          reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    LT              reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    LTE             reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    GT              reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    GTE             reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    NE              reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    EQUALS          reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    AND             reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    OR              reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    THEN            reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    )               reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    }               reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    RETURN          reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    BREAK           reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)
    ]               reduce using rule 110 (op_8 -> op_8 CIRCUMFLEX op_9 .)

  ! CIRCUMFLEX      [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! ,               [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! ;               [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! LOCAL           [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! FUNCTION        [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! DO              [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! WHILE           [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! REPEAT          [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! FOR             [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! IF              [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! (               [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! IDENTIFIER      [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! $end            [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! END             [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! UNTIL           [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! ELSEIF          [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! ELSE            [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! TIMES           [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! DIVIDE          [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! %               [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! PLUS            [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! MINUS           [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! CONCAT          [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! LT              [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! LTE             [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! GT              [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! GTE             [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! NE              [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! EQUALS          [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! AND             [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! OR              [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! THEN            [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! )               [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! }               [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! RETURN          [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! BREAK           [ reduce using rule 111 (op_8 -> op_9 .) ]
  ! ]               [ reduce using rule 111 (op_8 -> op_9 .) ]


state 170

    (13) stat -> LOCAL namelist = explist .
    (55) explist -> explist . , exp

    ;               reduce using rule 13 (stat -> LOCAL namelist = explist .)
    RETURN          reduce using rule 13 (stat -> LOCAL namelist = explist .)
    BREAK           reduce using rule 13 (stat -> LOCAL namelist = explist .)
    LOCAL           reduce using rule 13 (stat -> LOCAL namelist = explist .)
    FUNCTION        reduce using rule 13 (stat -> LOCAL namelist = explist .)
    DO              reduce using rule 13 (stat -> LOCAL namelist = explist .)
    WHILE           reduce using rule 13 (stat -> LOCAL namelist = explist .)
    REPEAT          reduce using rule 13 (stat -> LOCAL namelist = explist .)
    FOR             reduce using rule 13 (stat -> LOCAL namelist = explist .)
    IF              reduce using rule 13 (stat -> LOCAL namelist = explist .)
    (               reduce using rule 13 (stat -> LOCAL namelist = explist .)
    IDENTIFIER      reduce using rule 13 (stat -> LOCAL namelist = explist .)
    $end            reduce using rule 13 (stat -> LOCAL namelist = explist .)
    END             reduce using rule 13 (stat -> LOCAL namelist = explist .)
    UNTIL           reduce using rule 13 (stat -> LOCAL namelist = explist .)
    ELSEIF          reduce using rule 13 (stat -> LOCAL namelist = explist .)
    ELSE            reduce using rule 13 (stat -> LOCAL namelist = explist .)
    ,               shift and go to state 87


state 171

    (43) namelist -> namelist , name .

    =               reduce using rule 43 (namelist -> namelist , name .)
    ,               reduce using rule 43 (namelist -> namelist , name .)
    ;               reduce using rule 43 (namelist -> namelist , name .)
    RETURN          reduce using rule 43 (namelist -> namelist , name .)
    BREAK           reduce using rule 43 (namelist -> namelist , name .)
    LOCAL           reduce using rule 43 (namelist -> namelist , name .)
    FUNCTION        reduce using rule 43 (namelist -> namelist , name .)
    DO              reduce using rule 43 (namelist -> namelist , name .)
    WHILE           reduce using rule 43 (namelist -> namelist , name .)
    REPEAT          reduce using rule 43 (namelist -> namelist , name .)
    FOR             reduce using rule 43 (namelist -> namelist , name .)
    IF              reduce using rule 43 (namelist -> namelist , name .)
    (               reduce using rule 43 (namelist -> namelist , name .)
    IDENTIFIER      reduce using rule 43 (namelist -> namelist , name .)
    $end            reduce using rule 43 (namelist -> namelist , name .)
    END             reduce using rule 43 (namelist -> namelist , name .)
    UNTIL           reduce using rule 43 (namelist -> namelist , name .)
    ELSEIF          reduce using rule 43 (namelist -> namelist , name .)
    ELSE            reduce using rule 43 (namelist -> namelist , name .)
    IN              reduce using rule 43 (namelist -> namelist , name .)
    )               reduce using rule 43 (namelist -> namelist , name .)


state 172

    (16) stat -> LOCAL FUNCTION name funcbody .

    ;               reduce using rule 16 (stat -> LOCAL FUNCTION name funcbody .)
    RETURN          reduce using rule 16 (stat -> LOCAL FUNCTION name funcbody .)
    BREAK           reduce using rule 16 (stat -> LOCAL FUNCTION name funcbody .)
    LOCAL           reduce using rule 16 (stat -> LOCAL FUNCTION name funcbody .)
    FUNCTION        reduce using rule 16 (stat -> LOCAL FUNCTION name funcbody .)
    DO              reduce using rule 16 (stat -> LOCAL FUNCTION name funcbody .)
    WHILE           reduce using rule 16 (stat -> LOCAL FUNCTION name funcbody .)
    REPEAT          reduce using rule 16 (stat -> LOCAL FUNCTION name funcbody .)
    FOR             reduce using rule 16 (stat -> LOCAL FUNCTION name funcbody .)
    IF              reduce using rule 16 (stat -> LOCAL FUNCTION name funcbody .)
    (               reduce using rule 16 (stat -> LOCAL FUNCTION name funcbody .)
    IDENTIFIER      reduce using rule 16 (stat -> LOCAL FUNCTION name funcbody .)
    $end            reduce using rule 16 (stat -> LOCAL FUNCTION name funcbody .)
    END             reduce using rule 16 (stat -> LOCAL FUNCTION name funcbody .)
    UNTIL           reduce using rule 16 (stat -> LOCAL FUNCTION name funcbody .)
    ELSEIF          reduce using rule 16 (stat -> LOCAL FUNCTION name funcbody .)
    ELSE            reduce using rule 16 (stat -> LOCAL FUNCTION name funcbody .)


state 173

    (39) funcname -> funcname2 : name .

    (               reduce using rule 39 (funcname -> funcname2 : name .)


state 174

    (41) funcname2 -> funcname2 . name .

    :               reduce using rule 41 (funcname2 -> funcname2 . name .)
    .               reduce using rule 41 (funcname2 -> funcname2 . name .)
    (               reduce using rule 41 (funcname2 -> funcname2 . name .)


state 175

    (19) stat -> WHILE exp DO block . END

    END             shift and go to state 192


state 176

    (20) stat -> REPEAT block UNTIL exp .
    (112) op_9 -> exp .

  ! reduce/reduce conflict for ; resolved using rule 20 (stat -> REPEAT block UNTIL exp .)
  ! reduce/reduce conflict for RETURN resolved using rule 20 (stat -> REPEAT block UNTIL exp .)
  ! reduce/reduce conflict for BREAK resolved using rule 20 (stat -> REPEAT block UNTIL exp .)
  ! reduce/reduce conflict for LOCAL resolved using rule 20 (stat -> REPEAT block UNTIL exp .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 20 (stat -> REPEAT block UNTIL exp .)
  ! reduce/reduce conflict for DO resolved using rule 20 (stat -> REPEAT block UNTIL exp .)
  ! reduce/reduce conflict for WHILE resolved using rule 20 (stat -> REPEAT block UNTIL exp .)
  ! reduce/reduce conflict for REPEAT resolved using rule 20 (stat -> REPEAT block UNTIL exp .)
  ! reduce/reduce conflict for FOR resolved using rule 20 (stat -> REPEAT block UNTIL exp .)
  ! reduce/reduce conflict for IF resolved using rule 20 (stat -> REPEAT block UNTIL exp .)
  ! reduce/reduce conflict for ( resolved using rule 20 (stat -> REPEAT block UNTIL exp .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 20 (stat -> REPEAT block UNTIL exp .)
  ! reduce/reduce conflict for $end resolved using rule 20 (stat -> REPEAT block UNTIL exp .)
  ! reduce/reduce conflict for END resolved using rule 20 (stat -> REPEAT block UNTIL exp .)
  ! reduce/reduce conflict for UNTIL resolved using rule 20 (stat -> REPEAT block UNTIL exp .)
  ! reduce/reduce conflict for ELSEIF resolved using rule 20 (stat -> REPEAT block UNTIL exp .)
  ! reduce/reduce conflict for ELSE resolved using rule 20 (stat -> REPEAT block UNTIL exp .)
    ;               reduce using rule 20 (stat -> REPEAT block UNTIL exp .)
    RETURN          reduce using rule 20 (stat -> REPEAT block UNTIL exp .)
    BREAK           reduce using rule 20 (stat -> REPEAT block UNTIL exp .)
    LOCAL           reduce using rule 20 (stat -> REPEAT block UNTIL exp .)
    FUNCTION        reduce using rule 20 (stat -> REPEAT block UNTIL exp .)
    DO              reduce using rule 20 (stat -> REPEAT block UNTIL exp .)
    WHILE           reduce using rule 20 (stat -> REPEAT block UNTIL exp .)
    REPEAT          reduce using rule 20 (stat -> REPEAT block UNTIL exp .)
    FOR             reduce using rule 20 (stat -> REPEAT block UNTIL exp .)
    IF              reduce using rule 20 (stat -> REPEAT block UNTIL exp .)
    (               reduce using rule 20 (stat -> REPEAT block UNTIL exp .)
    IDENTIFIER      reduce using rule 20 (stat -> REPEAT block UNTIL exp .)
    $end            reduce using rule 20 (stat -> REPEAT block UNTIL exp .)
    END             reduce using rule 20 (stat -> REPEAT block UNTIL exp .)
    UNTIL           reduce using rule 20 (stat -> REPEAT block UNTIL exp .)
    ELSEIF          reduce using rule 20 (stat -> REPEAT block UNTIL exp .)
    ELSE            reduce using rule 20 (stat -> REPEAT block UNTIL exp .)
    CIRCUMFLEX      reduce using rule 112 (op_9 -> exp .)
    TIMES           reduce using rule 112 (op_9 -> exp .)
    DIVIDE          reduce using rule 112 (op_9 -> exp .)
    %               reduce using rule 112 (op_9 -> exp .)
    PLUS            reduce using rule 112 (op_9 -> exp .)
    MINUS           reduce using rule 112 (op_9 -> exp .)
    CONCAT          reduce using rule 112 (op_9 -> exp .)
    LT              reduce using rule 112 (op_9 -> exp .)
    LTE             reduce using rule 112 (op_9 -> exp .)
    GT              reduce using rule 112 (op_9 -> exp .)
    GTE             reduce using rule 112 (op_9 -> exp .)
    NE              reduce using rule 112 (op_9 -> exp .)
    EQUALS          reduce using rule 112 (op_9 -> exp .)
    AND             reduce using rule 112 (op_9 -> exp .)
    OR              reduce using rule 112 (op_9 -> exp .)

  ! ;               [ reduce using rule 112 (op_9 -> exp .) ]
  ! RETURN          [ reduce using rule 112 (op_9 -> exp .) ]
  ! BREAK           [ reduce using rule 112 (op_9 -> exp .) ]
  ! LOCAL           [ reduce using rule 112 (op_9 -> exp .) ]
  ! FUNCTION        [ reduce using rule 112 (op_9 -> exp .) ]
  ! DO              [ reduce using rule 112 (op_9 -> exp .) ]
  ! WHILE           [ reduce using rule 112 (op_9 -> exp .) ]
  ! REPEAT          [ reduce using rule 112 (op_9 -> exp .) ]
  ! FOR             [ reduce using rule 112 (op_9 -> exp .) ]
  ! IF              [ reduce using rule 112 (op_9 -> exp .) ]
  ! (               [ reduce using rule 112 (op_9 -> exp .) ]
  ! IDENTIFIER      [ reduce using rule 112 (op_9 -> exp .) ]
  ! $end            [ reduce using rule 112 (op_9 -> exp .) ]
  ! END             [ reduce using rule 112 (op_9 -> exp .) ]
  ! UNTIL           [ reduce using rule 112 (op_9 -> exp .) ]
  ! ELSEIF          [ reduce using rule 112 (op_9 -> exp .) ]
  ! ELSE            [ reduce using rule 112 (op_9 -> exp .) ]


state 177

    (21) stat -> if elseiflist else END .

    ;               reduce using rule 21 (stat -> if elseiflist else END .)
    RETURN          reduce using rule 21 (stat -> if elseiflist else END .)
    BREAK           reduce using rule 21 (stat -> if elseiflist else END .)
    LOCAL           reduce using rule 21 (stat -> if elseiflist else END .)
    FUNCTION        reduce using rule 21 (stat -> if elseiflist else END .)
    DO              reduce using rule 21 (stat -> if elseiflist else END .)
    WHILE           reduce using rule 21 (stat -> if elseiflist else END .)
    REPEAT          reduce using rule 21 (stat -> if elseiflist else END .)
    FOR             reduce using rule 21 (stat -> if elseiflist else END .)
    IF              reduce using rule 21 (stat -> if elseiflist else END .)
    (               reduce using rule 21 (stat -> if elseiflist else END .)
    IDENTIFIER      reduce using rule 21 (stat -> if elseiflist else END .)
    $end            reduce using rule 21 (stat -> if elseiflist else END .)
    END             reduce using rule 21 (stat -> if elseiflist else END .)
    UNTIL           reduce using rule 21 (stat -> if elseiflist else END .)
    ELSEIF          reduce using rule 21 (stat -> if elseiflist else END .)
    ELSE            reduce using rule 21 (stat -> if elseiflist else END .)


state 178

    (30) else -> ELSE block .

    END             reduce using rule 30 (else -> ELSE block .)


state 179

    (29) elseif -> ELSEIF exp THEN . block
    (1) block -> . chunk
    (2) chunk -> . chunk2 laststat
    (3) chunk -> . chunk2
    (4) chunk -> . laststat
    (5) chunk2 -> . stat optsemi
    (6) chunk2 -> . chunk stat optsemi
    (9) laststat -> . RETURN explist optsemi
    (10) laststat -> . RETURN optsemi
    (11) laststat -> . BREAK optsemi
    (12) stat -> . varlist = explist
    (13) stat -> . LOCAL namelist = explist
    (14) stat -> . LOCAL namelist
    (15) stat -> . FUNCTION funcname funcbody
    (16) stat -> . LOCAL FUNCTION name funcbody
    (17) stat -> . functioncall
    (18) stat -> . DO block END
    (19) stat -> . WHILE exp DO block END
    (20) stat -> . REPEAT block UNTIL exp
    (21) stat -> . if elseiflist else END
    (22) stat -> . FOR name = exp , exp DO block END
    (23) stat -> . FOR name = exp , exp , exp DO block END
    (24) stat -> . FOR namelist IN explist DO block END
    (35) varlist -> . var
    (36) varlist -> . varlist , var
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (25) if -> . IF exp THEN block
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (37) name -> . IDENTIFIER

    RETURN          shift and go to state 6
    BREAK           shift and go to state 7
    LOCAL           shift and go to state 9
    FUNCTION        shift and go to state 10
    DO              shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    FOR             shift and go to state 17
    IF              shift and go to state 20
    (               shift and go to state 21
    IDENTIFIER      shift and go to state 22

    block                          shift and go to state 193
    chunk                          shift and go to state 2
    chunk2                         shift and go to state 3
    laststat                       shift and go to state 4
    stat                           shift and go to state 5
    varlist                        shift and go to state 8
    name                           shift and go to state 11
    functioncall                   shift and go to state 12
    if                             shift and go to state 16
    var                            shift and go to state 18
    prefixexp                      shift and go to state 19

state 180

    (22) stat -> FOR name = exp . , exp DO block END
    (23) stat -> FOR name = exp . , exp , exp DO block END
    (112) op_9 -> exp .

  ! shift/reduce conflict for , resolved as shift
    ,               shift and go to state 194
    CIRCUMFLEX      reduce using rule 112 (op_9 -> exp .)
    TIMES           reduce using rule 112 (op_9 -> exp .)
    DIVIDE          reduce using rule 112 (op_9 -> exp .)
    %               reduce using rule 112 (op_9 -> exp .)
    PLUS            reduce using rule 112 (op_9 -> exp .)
    MINUS           reduce using rule 112 (op_9 -> exp .)
    CONCAT          reduce using rule 112 (op_9 -> exp .)
    LT              reduce using rule 112 (op_9 -> exp .)
    LTE             reduce using rule 112 (op_9 -> exp .)
    GT              reduce using rule 112 (op_9 -> exp .)
    GTE             reduce using rule 112 (op_9 -> exp .)
    NE              reduce using rule 112 (op_9 -> exp .)
    EQUALS          reduce using rule 112 (op_9 -> exp .)
    AND             reduce using rule 112 (op_9 -> exp .)
    OR              reduce using rule 112 (op_9 -> exp .)

  ! ,               [ reduce using rule 112 (op_9 -> exp .) ]


state 181

    (24) stat -> FOR namelist IN explist . DO block END
    (55) explist -> explist . , exp

    DO              shift and go to state 195
    ,               shift and go to state 87


state 182

    (61) functioncall -> prefixexp : name args .

    ;               reduce using rule 61 (functioncall -> prefixexp : name args .)
    RETURN          reduce using rule 61 (functioncall -> prefixexp : name args .)
    BREAK           reduce using rule 61 (functioncall -> prefixexp : name args .)
    LOCAL           reduce using rule 61 (functioncall -> prefixexp : name args .)
    FUNCTION        reduce using rule 61 (functioncall -> prefixexp : name args .)
    DO              reduce using rule 61 (functioncall -> prefixexp : name args .)
    WHILE           reduce using rule 61 (functioncall -> prefixexp : name args .)
    REPEAT          reduce using rule 61 (functioncall -> prefixexp : name args .)
    FOR             reduce using rule 61 (functioncall -> prefixexp : name args .)
    IF              reduce using rule 61 (functioncall -> prefixexp : name args .)
    (               reduce using rule 61 (functioncall -> prefixexp : name args .)
    IDENTIFIER      reduce using rule 61 (functioncall -> prefixexp : name args .)
    $end            reduce using rule 61 (functioncall -> prefixexp : name args .)
    :               reduce using rule 61 (functioncall -> prefixexp : name args .)
    [               reduce using rule 61 (functioncall -> prefixexp : name args .)
    .               reduce using rule 61 (functioncall -> prefixexp : name args .)
    {               reduce using rule 61 (functioncall -> prefixexp : name args .)
    STRING          reduce using rule 61 (functioncall -> prefixexp : name args .)
    END             reduce using rule 61 (functioncall -> prefixexp : name args .)
    UNTIL           reduce using rule 61 (functioncall -> prefixexp : name args .)
    ELSEIF          reduce using rule 61 (functioncall -> prefixexp : name args .)
    ELSE            reduce using rule 61 (functioncall -> prefixexp : name args .)
    ,               reduce using rule 61 (functioncall -> prefixexp : name args .)
    CIRCUMFLEX      reduce using rule 61 (functioncall -> prefixexp : name args .)
    TIMES           reduce using rule 61 (functioncall -> prefixexp : name args .)
    DIVIDE          reduce using rule 61 (functioncall -> prefixexp : name args .)
    %               reduce using rule 61 (functioncall -> prefixexp : name args .)
    PLUS            reduce using rule 61 (functioncall -> prefixexp : name args .)
    MINUS           reduce using rule 61 (functioncall -> prefixexp : name args .)
    CONCAT          reduce using rule 61 (functioncall -> prefixexp : name args .)
    LT              reduce using rule 61 (functioncall -> prefixexp : name args .)
    LTE             reduce using rule 61 (functioncall -> prefixexp : name args .)
    GT              reduce using rule 61 (functioncall -> prefixexp : name args .)
    GTE             reduce using rule 61 (functioncall -> prefixexp : name args .)
    NE              reduce using rule 61 (functioncall -> prefixexp : name args .)
    EQUALS          reduce using rule 61 (functioncall -> prefixexp : name args .)
    AND             reduce using rule 61 (functioncall -> prefixexp : name args .)
    OR              reduce using rule 61 (functioncall -> prefixexp : name args .)
    THEN            reduce using rule 61 (functioncall -> prefixexp : name args .)
    )               reduce using rule 61 (functioncall -> prefixexp : name args .)
    }               reduce using rule 61 (functioncall -> prefixexp : name args .)
    ]               reduce using rule 61 (functioncall -> prefixexp : name args .)


state 183

    (33) var -> prefixexp [ exp ] .

    =               reduce using rule 33 (var -> prefixexp [ exp ] .)
    ,               reduce using rule 33 (var -> prefixexp [ exp ] .)
    :               reduce using rule 33 (var -> prefixexp [ exp ] .)
    [               reduce using rule 33 (var -> prefixexp [ exp ] .)
    .               reduce using rule 33 (var -> prefixexp [ exp ] .)
    (               reduce using rule 33 (var -> prefixexp [ exp ] .)
    {               reduce using rule 33 (var -> prefixexp [ exp ] .)
    STRING          reduce using rule 33 (var -> prefixexp [ exp ] .)
    ;               reduce using rule 33 (var -> prefixexp [ exp ] .)
    LOCAL           reduce using rule 33 (var -> prefixexp [ exp ] .)
    FUNCTION        reduce using rule 33 (var -> prefixexp [ exp ] .)
    DO              reduce using rule 33 (var -> prefixexp [ exp ] .)
    WHILE           reduce using rule 33 (var -> prefixexp [ exp ] .)
    REPEAT          reduce using rule 33 (var -> prefixexp [ exp ] .)
    FOR             reduce using rule 33 (var -> prefixexp [ exp ] .)
    IF              reduce using rule 33 (var -> prefixexp [ exp ] .)
    IDENTIFIER      reduce using rule 33 (var -> prefixexp [ exp ] .)
    $end            reduce using rule 33 (var -> prefixexp [ exp ] .)
    END             reduce using rule 33 (var -> prefixexp [ exp ] .)
    UNTIL           reduce using rule 33 (var -> prefixexp [ exp ] .)
    ELSEIF          reduce using rule 33 (var -> prefixexp [ exp ] .)
    ELSE            reduce using rule 33 (var -> prefixexp [ exp ] .)
    CIRCUMFLEX      reduce using rule 33 (var -> prefixexp [ exp ] .)
    TIMES           reduce using rule 33 (var -> prefixexp [ exp ] .)
    DIVIDE          reduce using rule 33 (var -> prefixexp [ exp ] .)
    %               reduce using rule 33 (var -> prefixexp [ exp ] .)
    PLUS            reduce using rule 33 (var -> prefixexp [ exp ] .)
    MINUS           reduce using rule 33 (var -> prefixexp [ exp ] .)
    CONCAT          reduce using rule 33 (var -> prefixexp [ exp ] .)
    LT              reduce using rule 33 (var -> prefixexp [ exp ] .)
    LTE             reduce using rule 33 (var -> prefixexp [ exp ] .)
    GT              reduce using rule 33 (var -> prefixexp [ exp ] .)
    GTE             reduce using rule 33 (var -> prefixexp [ exp ] .)
    NE              reduce using rule 33 (var -> prefixexp [ exp ] .)
    EQUALS          reduce using rule 33 (var -> prefixexp [ exp ] .)
    AND             reduce using rule 33 (var -> prefixexp [ exp ] .)
    OR              reduce using rule 33 (var -> prefixexp [ exp ] .)
    THEN            reduce using rule 33 (var -> prefixexp [ exp ] .)
    )               reduce using rule 33 (var -> prefixexp [ exp ] .)
    }               reduce using rule 33 (var -> prefixexp [ exp ] .)
    RETURN          reduce using rule 33 (var -> prefixexp [ exp ] .)
    BREAK           reduce using rule 33 (var -> prefixexp [ exp ] .)
    ]               reduce using rule 33 (var -> prefixexp [ exp ] .)


state 184

    (69) args -> ( explist ) .

    ;               reduce using rule 69 (args -> ( explist ) .)
    RETURN          reduce using rule 69 (args -> ( explist ) .)
    BREAK           reduce using rule 69 (args -> ( explist ) .)
    LOCAL           reduce using rule 69 (args -> ( explist ) .)
    FUNCTION        reduce using rule 69 (args -> ( explist ) .)
    DO              reduce using rule 69 (args -> ( explist ) .)
    WHILE           reduce using rule 69 (args -> ( explist ) .)
    REPEAT          reduce using rule 69 (args -> ( explist ) .)
    FOR             reduce using rule 69 (args -> ( explist ) .)
    IF              reduce using rule 69 (args -> ( explist ) .)
    (               reduce using rule 69 (args -> ( explist ) .)
    IDENTIFIER      reduce using rule 69 (args -> ( explist ) .)
    $end            reduce using rule 69 (args -> ( explist ) .)
    :               reduce using rule 69 (args -> ( explist ) .)
    [               reduce using rule 69 (args -> ( explist ) .)
    .               reduce using rule 69 (args -> ( explist ) .)
    {               reduce using rule 69 (args -> ( explist ) .)
    STRING          reduce using rule 69 (args -> ( explist ) .)
    END             reduce using rule 69 (args -> ( explist ) .)
    UNTIL           reduce using rule 69 (args -> ( explist ) .)
    ELSEIF          reduce using rule 69 (args -> ( explist ) .)
    ELSE            reduce using rule 69 (args -> ( explist ) .)
    ,               reduce using rule 69 (args -> ( explist ) .)
    CIRCUMFLEX      reduce using rule 69 (args -> ( explist ) .)
    TIMES           reduce using rule 69 (args -> ( explist ) .)
    DIVIDE          reduce using rule 69 (args -> ( explist ) .)
    %               reduce using rule 69 (args -> ( explist ) .)
    PLUS            reduce using rule 69 (args -> ( explist ) .)
    MINUS           reduce using rule 69 (args -> ( explist ) .)
    CONCAT          reduce using rule 69 (args -> ( explist ) .)
    LT              reduce using rule 69 (args -> ( explist ) .)
    LTE             reduce using rule 69 (args -> ( explist ) .)
    GT              reduce using rule 69 (args -> ( explist ) .)
    GTE             reduce using rule 69 (args -> ( explist ) .)
    NE              reduce using rule 69 (args -> ( explist ) .)
    EQUALS          reduce using rule 69 (args -> ( explist ) .)
    AND             reduce using rule 69 (args -> ( explist ) .)
    OR              reduce using rule 69 (args -> ( explist ) .)
    THEN            reduce using rule 69 (args -> ( explist ) .)
    )               reduce using rule 69 (args -> ( explist ) .)
    }               reduce using rule 69 (args -> ( explist ) .)
    ]               reduce using rule 69 (args -> ( explist ) .)


state 185

    (25) if -> IF exp THEN block .

    ELSEIF          reduce using rule 25 (if -> IF exp THEN block .)
    ELSE            reduce using rule 25 (if -> IF exp THEN block .)
    END             reduce using rule 25 (if -> IF exp THEN block .)


state 186

    (63) funcbody -> ( parlist ) . block END
    (1) block -> . chunk
    (2) chunk -> . chunk2 laststat
    (3) chunk -> . chunk2
    (4) chunk -> . laststat
    (5) chunk2 -> . stat optsemi
    (6) chunk2 -> . chunk stat optsemi
    (9) laststat -> . RETURN explist optsemi
    (10) laststat -> . RETURN optsemi
    (11) laststat -> . BREAK optsemi
    (12) stat -> . varlist = explist
    (13) stat -> . LOCAL namelist = explist
    (14) stat -> . LOCAL namelist
    (15) stat -> . FUNCTION funcname funcbody
    (16) stat -> . LOCAL FUNCTION name funcbody
    (17) stat -> . functioncall
    (18) stat -> . DO block END
    (19) stat -> . WHILE exp DO block END
    (20) stat -> . REPEAT block UNTIL exp
    (21) stat -> . if elseiflist else END
    (22) stat -> . FOR name = exp , exp DO block END
    (23) stat -> . FOR name = exp , exp , exp DO block END
    (24) stat -> . FOR namelist IN explist DO block END
    (35) varlist -> . var
    (36) varlist -> . varlist , var
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (25) if -> . IF exp THEN block
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (37) name -> . IDENTIFIER

    RETURN          shift and go to state 6
    BREAK           shift and go to state 7
    LOCAL           shift and go to state 9
    FUNCTION        shift and go to state 10
    DO              shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    FOR             shift and go to state 17
    IF              shift and go to state 20
    (               shift and go to state 21
    IDENTIFIER      shift and go to state 22

    block                          shift and go to state 196
    chunk                          shift and go to state 2
    chunk2                         shift and go to state 3
    laststat                       shift and go to state 4
    stat                           shift and go to state 5
    varlist                        shift and go to state 8
    name                           shift and go to state 11
    functioncall                   shift and go to state 12
    if                             shift and go to state 16
    var                            shift and go to state 18
    prefixexp                      shift and go to state 19

state 187

    (64) funcbody -> ( ) block . END

    END             shift and go to state 197


state 188

    (66) parlist -> namelist , . TDOT
    (43) namelist -> namelist , . name
    (37) name -> . IDENTIFIER

    TDOT            shift and go to state 198
    IDENTIFIER      shift and go to state 22

    name                           shift and go to state 171

state 189

    (79) fieldlist2 -> fieldlist2 fieldsep field .

    ,               reduce using rule 79 (fieldlist2 -> fieldlist2 fieldsep field .)
    ;               reduce using rule 79 (fieldlist2 -> fieldlist2 fieldsep field .)
    }               reduce using rule 79 (fieldlist2 -> fieldlist2 fieldsep field .)


state 190

    (74) field -> [ exp ] . = exp

    =               shift and go to state 199


state 191

    (75) field -> name = exp .
    (112) op_9 -> exp .

  ! reduce/reduce conflict for , resolved using rule 75 (field -> name = exp .)
  ! reduce/reduce conflict for ; resolved using rule 75 (field -> name = exp .)
  ! reduce/reduce conflict for } resolved using rule 75 (field -> name = exp .)
    ,               reduce using rule 75 (field -> name = exp .)
    ;               reduce using rule 75 (field -> name = exp .)
    }               reduce using rule 75 (field -> name = exp .)
    CIRCUMFLEX      reduce using rule 112 (op_9 -> exp .)
    TIMES           reduce using rule 112 (op_9 -> exp .)
    DIVIDE          reduce using rule 112 (op_9 -> exp .)
    %               reduce using rule 112 (op_9 -> exp .)
    PLUS            reduce using rule 112 (op_9 -> exp .)
    MINUS           reduce using rule 112 (op_9 -> exp .)
    CONCAT          reduce using rule 112 (op_9 -> exp .)
    LT              reduce using rule 112 (op_9 -> exp .)
    LTE             reduce using rule 112 (op_9 -> exp .)
    GT              reduce using rule 112 (op_9 -> exp .)
    GTE             reduce using rule 112 (op_9 -> exp .)
    NE              reduce using rule 112 (op_9 -> exp .)
    EQUALS          reduce using rule 112 (op_9 -> exp .)
    AND             reduce using rule 112 (op_9 -> exp .)
    OR              reduce using rule 112 (op_9 -> exp .)

  ! ,               [ reduce using rule 112 (op_9 -> exp .) ]
  ! ;               [ reduce using rule 112 (op_9 -> exp .) ]
  ! }               [ reduce using rule 112 (op_9 -> exp .) ]


state 192

    (19) stat -> WHILE exp DO block END .

    ;               reduce using rule 19 (stat -> WHILE exp DO block END .)
    RETURN          reduce using rule 19 (stat -> WHILE exp DO block END .)
    BREAK           reduce using rule 19 (stat -> WHILE exp DO block END .)
    LOCAL           reduce using rule 19 (stat -> WHILE exp DO block END .)
    FUNCTION        reduce using rule 19 (stat -> WHILE exp DO block END .)
    DO              reduce using rule 19 (stat -> WHILE exp DO block END .)
    WHILE           reduce using rule 19 (stat -> WHILE exp DO block END .)
    REPEAT          reduce using rule 19 (stat -> WHILE exp DO block END .)
    FOR             reduce using rule 19 (stat -> WHILE exp DO block END .)
    IF              reduce using rule 19 (stat -> WHILE exp DO block END .)
    (               reduce using rule 19 (stat -> WHILE exp DO block END .)
    IDENTIFIER      reduce using rule 19 (stat -> WHILE exp DO block END .)
    $end            reduce using rule 19 (stat -> WHILE exp DO block END .)
    END             reduce using rule 19 (stat -> WHILE exp DO block END .)
    UNTIL           reduce using rule 19 (stat -> WHILE exp DO block END .)
    ELSEIF          reduce using rule 19 (stat -> WHILE exp DO block END .)
    ELSE            reduce using rule 19 (stat -> WHILE exp DO block END .)


state 193

    (29) elseif -> ELSEIF exp THEN block .

    ELSE            reduce using rule 29 (elseif -> ELSEIF exp THEN block .)
    ELSEIF          reduce using rule 29 (elseif -> ELSEIF exp THEN block .)
    END             reduce using rule 29 (elseif -> ELSEIF exp THEN block .)


state 194

    (22) stat -> FOR name = exp , . exp DO block END
    (23) stat -> FOR name = exp , . exp , exp DO block END
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp

    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    name                           shift and go to state 11
    exp                            shift and go to state 200
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57

state 195

    (24) stat -> FOR namelist IN explist DO . block END
    (1) block -> . chunk
    (2) chunk -> . chunk2 laststat
    (3) chunk -> . chunk2
    (4) chunk -> . laststat
    (5) chunk2 -> . stat optsemi
    (6) chunk2 -> . chunk stat optsemi
    (9) laststat -> . RETURN explist optsemi
    (10) laststat -> . RETURN optsemi
    (11) laststat -> . BREAK optsemi
    (12) stat -> . varlist = explist
    (13) stat -> . LOCAL namelist = explist
    (14) stat -> . LOCAL namelist
    (15) stat -> . FUNCTION funcname funcbody
    (16) stat -> . LOCAL FUNCTION name funcbody
    (17) stat -> . functioncall
    (18) stat -> . DO block END
    (19) stat -> . WHILE exp DO block END
    (20) stat -> . REPEAT block UNTIL exp
    (21) stat -> . if elseiflist else END
    (22) stat -> . FOR name = exp , exp DO block END
    (23) stat -> . FOR name = exp , exp , exp DO block END
    (24) stat -> . FOR namelist IN explist DO block END
    (35) varlist -> . var
    (36) varlist -> . varlist , var
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (25) if -> . IF exp THEN block
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (37) name -> . IDENTIFIER

    RETURN          shift and go to state 6
    BREAK           shift and go to state 7
    LOCAL           shift and go to state 9
    FUNCTION        shift and go to state 10
    DO              shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    FOR             shift and go to state 17
    IF              shift and go to state 20
    (               shift and go to state 21
    IDENTIFIER      shift and go to state 22

    block                          shift and go to state 201
    chunk                          shift and go to state 2
    chunk2                         shift and go to state 3
    laststat                       shift and go to state 4
    stat                           shift and go to state 5
    varlist                        shift and go to state 8
    name                           shift and go to state 11
    functioncall                   shift and go to state 12
    if                             shift and go to state 16
    var                            shift and go to state 18
    prefixexp                      shift and go to state 19

state 196

    (63) funcbody -> ( parlist ) block . END

    END             shift and go to state 202


state 197

    (64) funcbody -> ( ) block END .

    ,               reduce using rule 64 (funcbody -> ( ) block END .)
    ;               reduce using rule 64 (funcbody -> ( ) block END .)
    LOCAL           reduce using rule 64 (funcbody -> ( ) block END .)
    FUNCTION        reduce using rule 64 (funcbody -> ( ) block END .)
    DO              reduce using rule 64 (funcbody -> ( ) block END .)
    WHILE           reduce using rule 64 (funcbody -> ( ) block END .)
    REPEAT          reduce using rule 64 (funcbody -> ( ) block END .)
    FOR             reduce using rule 64 (funcbody -> ( ) block END .)
    IF              reduce using rule 64 (funcbody -> ( ) block END .)
    (               reduce using rule 64 (funcbody -> ( ) block END .)
    IDENTIFIER      reduce using rule 64 (funcbody -> ( ) block END .)
    $end            reduce using rule 64 (funcbody -> ( ) block END .)
    END             reduce using rule 64 (funcbody -> ( ) block END .)
    UNTIL           reduce using rule 64 (funcbody -> ( ) block END .)
    ELSEIF          reduce using rule 64 (funcbody -> ( ) block END .)
    ELSE            reduce using rule 64 (funcbody -> ( ) block END .)
    CIRCUMFLEX      reduce using rule 64 (funcbody -> ( ) block END .)
    TIMES           reduce using rule 64 (funcbody -> ( ) block END .)
    DIVIDE          reduce using rule 64 (funcbody -> ( ) block END .)
    %               reduce using rule 64 (funcbody -> ( ) block END .)
    PLUS            reduce using rule 64 (funcbody -> ( ) block END .)
    MINUS           reduce using rule 64 (funcbody -> ( ) block END .)
    CONCAT          reduce using rule 64 (funcbody -> ( ) block END .)
    LT              reduce using rule 64 (funcbody -> ( ) block END .)
    LTE             reduce using rule 64 (funcbody -> ( ) block END .)
    GT              reduce using rule 64 (funcbody -> ( ) block END .)
    GTE             reduce using rule 64 (funcbody -> ( ) block END .)
    NE              reduce using rule 64 (funcbody -> ( ) block END .)
    EQUALS          reduce using rule 64 (funcbody -> ( ) block END .)
    AND             reduce using rule 64 (funcbody -> ( ) block END .)
    OR              reduce using rule 64 (funcbody -> ( ) block END .)
    THEN            reduce using rule 64 (funcbody -> ( ) block END .)
    )               reduce using rule 64 (funcbody -> ( ) block END .)
    }               reduce using rule 64 (funcbody -> ( ) block END .)
    RETURN          reduce using rule 64 (funcbody -> ( ) block END .)
    BREAK           reduce using rule 64 (funcbody -> ( ) block END .)
    ]               reduce using rule 64 (funcbody -> ( ) block END .)


state 198

    (66) parlist -> namelist , TDOT .

    )               reduce using rule 66 (parlist -> namelist , TDOT .)


state 199

    (74) field -> [ exp ] = . exp
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp

    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    exp                            shift and go to state 203
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    name                           shift and go to state 11
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57

state 200

    (22) stat -> FOR name = exp , exp . DO block END
    (23) stat -> FOR name = exp , exp . , exp DO block END
    (112) op_9 -> exp .

  ! shift/reduce conflict for DO resolved as shift
  ! shift/reduce conflict for , resolved as shift
    DO              shift and go to state 205
    ,               shift and go to state 204
    CIRCUMFLEX      reduce using rule 112 (op_9 -> exp .)
    TIMES           reduce using rule 112 (op_9 -> exp .)
    DIVIDE          reduce using rule 112 (op_9 -> exp .)
    %               reduce using rule 112 (op_9 -> exp .)
    PLUS            reduce using rule 112 (op_9 -> exp .)
    MINUS           reduce using rule 112 (op_9 -> exp .)
    CONCAT          reduce using rule 112 (op_9 -> exp .)
    LT              reduce using rule 112 (op_9 -> exp .)
    LTE             reduce using rule 112 (op_9 -> exp .)
    GT              reduce using rule 112 (op_9 -> exp .)
    GTE             reduce using rule 112 (op_9 -> exp .)
    NE              reduce using rule 112 (op_9 -> exp .)
    EQUALS          reduce using rule 112 (op_9 -> exp .)
    AND             reduce using rule 112 (op_9 -> exp .)
    OR              reduce using rule 112 (op_9 -> exp .)

  ! DO              [ reduce using rule 112 (op_9 -> exp .) ]
  ! ,               [ reduce using rule 112 (op_9 -> exp .) ]


state 201

    (24) stat -> FOR namelist IN explist DO block . END

    END             shift and go to state 206


state 202

    (63) funcbody -> ( parlist ) block END .

    ,               reduce using rule 63 (funcbody -> ( parlist ) block END .)
    ;               reduce using rule 63 (funcbody -> ( parlist ) block END .)
    LOCAL           reduce using rule 63 (funcbody -> ( parlist ) block END .)
    FUNCTION        reduce using rule 63 (funcbody -> ( parlist ) block END .)
    DO              reduce using rule 63 (funcbody -> ( parlist ) block END .)
    WHILE           reduce using rule 63 (funcbody -> ( parlist ) block END .)
    REPEAT          reduce using rule 63 (funcbody -> ( parlist ) block END .)
    FOR             reduce using rule 63 (funcbody -> ( parlist ) block END .)
    IF              reduce using rule 63 (funcbody -> ( parlist ) block END .)
    (               reduce using rule 63 (funcbody -> ( parlist ) block END .)
    IDENTIFIER      reduce using rule 63 (funcbody -> ( parlist ) block END .)
    $end            reduce using rule 63 (funcbody -> ( parlist ) block END .)
    END             reduce using rule 63 (funcbody -> ( parlist ) block END .)
    UNTIL           reduce using rule 63 (funcbody -> ( parlist ) block END .)
    ELSEIF          reduce using rule 63 (funcbody -> ( parlist ) block END .)
    ELSE            reduce using rule 63 (funcbody -> ( parlist ) block END .)
    CIRCUMFLEX      reduce using rule 63 (funcbody -> ( parlist ) block END .)
    TIMES           reduce using rule 63 (funcbody -> ( parlist ) block END .)
    DIVIDE          reduce using rule 63 (funcbody -> ( parlist ) block END .)
    %               reduce using rule 63 (funcbody -> ( parlist ) block END .)
    PLUS            reduce using rule 63 (funcbody -> ( parlist ) block END .)
    MINUS           reduce using rule 63 (funcbody -> ( parlist ) block END .)
    CONCAT          reduce using rule 63 (funcbody -> ( parlist ) block END .)
    LT              reduce using rule 63 (funcbody -> ( parlist ) block END .)
    LTE             reduce using rule 63 (funcbody -> ( parlist ) block END .)
    GT              reduce using rule 63 (funcbody -> ( parlist ) block END .)
    GTE             reduce using rule 63 (funcbody -> ( parlist ) block END .)
    NE              reduce using rule 63 (funcbody -> ( parlist ) block END .)
    EQUALS          reduce using rule 63 (funcbody -> ( parlist ) block END .)
    AND             reduce using rule 63 (funcbody -> ( parlist ) block END .)
    OR              reduce using rule 63 (funcbody -> ( parlist ) block END .)
    THEN            reduce using rule 63 (funcbody -> ( parlist ) block END .)
    )               reduce using rule 63 (funcbody -> ( parlist ) block END .)
    }               reduce using rule 63 (funcbody -> ( parlist ) block END .)
    RETURN          reduce using rule 63 (funcbody -> ( parlist ) block END .)
    BREAK           reduce using rule 63 (funcbody -> ( parlist ) block END .)
    ]               reduce using rule 63 (funcbody -> ( parlist ) block END .)


state 203

    (74) field -> [ exp ] = exp .
    (112) op_9 -> exp .

  ! reduce/reduce conflict for , resolved using rule 74 (field -> [ exp ] = exp .)
  ! reduce/reduce conflict for ; resolved using rule 74 (field -> [ exp ] = exp .)
  ! reduce/reduce conflict for } resolved using rule 74 (field -> [ exp ] = exp .)
    ,               reduce using rule 74 (field -> [ exp ] = exp .)
    ;               reduce using rule 74 (field -> [ exp ] = exp .)
    }               reduce using rule 74 (field -> [ exp ] = exp .)
    CIRCUMFLEX      reduce using rule 112 (op_9 -> exp .)
    TIMES           reduce using rule 112 (op_9 -> exp .)
    DIVIDE          reduce using rule 112 (op_9 -> exp .)
    %               reduce using rule 112 (op_9 -> exp .)
    PLUS            reduce using rule 112 (op_9 -> exp .)
    MINUS           reduce using rule 112 (op_9 -> exp .)
    CONCAT          reduce using rule 112 (op_9 -> exp .)
    LT              reduce using rule 112 (op_9 -> exp .)
    LTE             reduce using rule 112 (op_9 -> exp .)
    GT              reduce using rule 112 (op_9 -> exp .)
    GTE             reduce using rule 112 (op_9 -> exp .)
    NE              reduce using rule 112 (op_9 -> exp .)
    EQUALS          reduce using rule 112 (op_9 -> exp .)
    AND             reduce using rule 112 (op_9 -> exp .)
    OR              reduce using rule 112 (op_9 -> exp .)

  ! ,               [ reduce using rule 112 (op_9 -> exp .) ]
  ! ;               [ reduce using rule 112 (op_9 -> exp .) ]
  ! }               [ reduce using rule 112 (op_9 -> exp .) ]


state 204

    (23) stat -> FOR name = exp , exp , . exp DO block END
    (44) exp -> . NIL
    (45) exp -> . FALSE
    (46) exp -> . TRUE
    (47) exp -> . NUMBER
    (48) exp -> . string
    (49) exp -> . TDOT
    (50) exp -> . function
    (51) exp -> . prefixexp
    (52) exp -> . tableconstructor
    (53) exp -> . op
    (84) string -> . STRING
    (59) function -> . FUNCTION funcbody
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (72) tableconstructor -> . { fieldlist }
    (73) tableconstructor -> . { }
    (85) op -> . op_1
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (86) op_1 -> . op_1 OR op_2
    (87) op_1 -> . op_2
    (37) name -> . IDENTIFIER
    (88) op_2 -> . op_2 AND op_3
    (89) op_2 -> . op_3
    (90) op_3 -> . op_3 LT op_4
    (91) op_3 -> . op_3 LTE op_4
    (92) op_3 -> . op_3 GT op_4
    (93) op_3 -> . op_3 GTE op_4
    (94) op_3 -> . op_3 NE op_4
    (95) op_3 -> . op_3 EQUALS op_4
    (96) op_3 -> . op_4
    (97) op_4 -> . op_4 CONCAT op_5
    (98) op_4 -> . op_5
    (99) op_5 -> . op_5 PLUS op_6
    (100) op_5 -> . op_5 MINUS op_6
    (101) op_5 -> . op_6
    (102) op_6 -> . op_6 TIMES op_7
    (103) op_6 -> . op_6 DIVIDE op_7
    (104) op_6 -> . op_6 % op_7
    (105) op_6 -> . op_7
    (106) op_7 -> . NOT op_8
    (107) op_7 -> . HASH op_8
    (108) op_7 -> . MINUS op_8
    (109) op_7 -> . op_8
    (110) op_8 -> . op_8 CIRCUMFLEX op_9
    (111) op_8 -> . op_9
    (112) op_9 -> . exp

    NIL             shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    NUMBER          shift and go to state 34
    TDOT            shift and go to state 36
    STRING          shift and go to state 41
    FUNCTION        shift and go to state 42
    (               shift and go to state 21
    {               shift and go to state 45
    IDENTIFIER      shift and go to state 22
    NOT             shift and go to state 54
    HASH            shift and go to state 56
    MINUS           shift and go to state 52

    name                           shift and go to state 11
    exp                            shift and go to state 207
    string                         shift and go to state 35
    function                       shift and go to state 37
    prefixexp                      shift and go to state 38
    tableconstructor               shift and go to state 39
    op                             shift and go to state 40
    var                            shift and go to state 43
    functioncall                   shift and go to state 44
    op_1                           shift and go to state 46
    op_2                           shift and go to state 47
    op_3                           shift and go to state 48
    op_4                           shift and go to state 49
    op_5                           shift and go to state 50
    op_6                           shift and go to state 51
    op_7                           shift and go to state 53
    op_8                           shift and go to state 55
    op_9                           shift and go to state 57

state 205

    (22) stat -> FOR name = exp , exp DO . block END
    (1) block -> . chunk
    (2) chunk -> . chunk2 laststat
    (3) chunk -> . chunk2
    (4) chunk -> . laststat
    (5) chunk2 -> . stat optsemi
    (6) chunk2 -> . chunk stat optsemi
    (9) laststat -> . RETURN explist optsemi
    (10) laststat -> . RETURN optsemi
    (11) laststat -> . BREAK optsemi
    (12) stat -> . varlist = explist
    (13) stat -> . LOCAL namelist = explist
    (14) stat -> . LOCAL namelist
    (15) stat -> . FUNCTION funcname funcbody
    (16) stat -> . LOCAL FUNCTION name funcbody
    (17) stat -> . functioncall
    (18) stat -> . DO block END
    (19) stat -> . WHILE exp DO block END
    (20) stat -> . REPEAT block UNTIL exp
    (21) stat -> . if elseiflist else END
    (22) stat -> . FOR name = exp , exp DO block END
    (23) stat -> . FOR name = exp , exp , exp DO block END
    (24) stat -> . FOR namelist IN explist DO block END
    (35) varlist -> . var
    (36) varlist -> . varlist , var
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (25) if -> . IF exp THEN block
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (37) name -> . IDENTIFIER

    RETURN          shift and go to state 6
    BREAK           shift and go to state 7
    LOCAL           shift and go to state 9
    FUNCTION        shift and go to state 10
    DO              shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    FOR             shift and go to state 17
    IF              shift and go to state 20
    (               shift and go to state 21
    IDENTIFIER      shift and go to state 22

    name                           shift and go to state 11
    block                          shift and go to state 208
    chunk                          shift and go to state 2
    chunk2                         shift and go to state 3
    laststat                       shift and go to state 4
    stat                           shift and go to state 5
    varlist                        shift and go to state 8
    functioncall                   shift and go to state 12
    if                             shift and go to state 16
    var                            shift and go to state 18
    prefixexp                      shift and go to state 19

state 206

    (24) stat -> FOR namelist IN explist DO block END .

    ;               reduce using rule 24 (stat -> FOR namelist IN explist DO block END .)
    RETURN          reduce using rule 24 (stat -> FOR namelist IN explist DO block END .)
    BREAK           reduce using rule 24 (stat -> FOR namelist IN explist DO block END .)
    LOCAL           reduce using rule 24 (stat -> FOR namelist IN explist DO block END .)
    FUNCTION        reduce using rule 24 (stat -> FOR namelist IN explist DO block END .)
    DO              reduce using rule 24 (stat -> FOR namelist IN explist DO block END .)
    WHILE           reduce using rule 24 (stat -> FOR namelist IN explist DO block END .)
    REPEAT          reduce using rule 24 (stat -> FOR namelist IN explist DO block END .)
    FOR             reduce using rule 24 (stat -> FOR namelist IN explist DO block END .)
    IF              reduce using rule 24 (stat -> FOR namelist IN explist DO block END .)
    (               reduce using rule 24 (stat -> FOR namelist IN explist DO block END .)
    IDENTIFIER      reduce using rule 24 (stat -> FOR namelist IN explist DO block END .)
    $end            reduce using rule 24 (stat -> FOR namelist IN explist DO block END .)
    END             reduce using rule 24 (stat -> FOR namelist IN explist DO block END .)
    UNTIL           reduce using rule 24 (stat -> FOR namelist IN explist DO block END .)
    ELSEIF          reduce using rule 24 (stat -> FOR namelist IN explist DO block END .)
    ELSE            reduce using rule 24 (stat -> FOR namelist IN explist DO block END .)


state 207

    (23) stat -> FOR name = exp , exp , exp . DO block END
    (112) op_9 -> exp .

  ! shift/reduce conflict for DO resolved as shift
    DO              shift and go to state 209
    CIRCUMFLEX      reduce using rule 112 (op_9 -> exp .)
    TIMES           reduce using rule 112 (op_9 -> exp .)
    DIVIDE          reduce using rule 112 (op_9 -> exp .)
    %               reduce using rule 112 (op_9 -> exp .)
    PLUS            reduce using rule 112 (op_9 -> exp .)
    MINUS           reduce using rule 112 (op_9 -> exp .)
    CONCAT          reduce using rule 112 (op_9 -> exp .)
    LT              reduce using rule 112 (op_9 -> exp .)
    LTE             reduce using rule 112 (op_9 -> exp .)
    GT              reduce using rule 112 (op_9 -> exp .)
    GTE             reduce using rule 112 (op_9 -> exp .)
    NE              reduce using rule 112 (op_9 -> exp .)
    EQUALS          reduce using rule 112 (op_9 -> exp .)
    AND             reduce using rule 112 (op_9 -> exp .)
    OR              reduce using rule 112 (op_9 -> exp .)

  ! DO              [ reduce using rule 112 (op_9 -> exp .) ]


state 208

    (22) stat -> FOR name = exp , exp DO block . END

    END             shift and go to state 210


state 209

    (23) stat -> FOR name = exp , exp , exp DO . block END
    (1) block -> . chunk
    (2) chunk -> . chunk2 laststat
    (3) chunk -> . chunk2
    (4) chunk -> . laststat
    (5) chunk2 -> . stat optsemi
    (6) chunk2 -> . chunk stat optsemi
    (9) laststat -> . RETURN explist optsemi
    (10) laststat -> . RETURN optsemi
    (11) laststat -> . BREAK optsemi
    (12) stat -> . varlist = explist
    (13) stat -> . LOCAL namelist = explist
    (14) stat -> . LOCAL namelist
    (15) stat -> . FUNCTION funcname funcbody
    (16) stat -> . LOCAL FUNCTION name funcbody
    (17) stat -> . functioncall
    (18) stat -> . DO block END
    (19) stat -> . WHILE exp DO block END
    (20) stat -> . REPEAT block UNTIL exp
    (21) stat -> . if elseiflist else END
    (22) stat -> . FOR name = exp , exp DO block END
    (23) stat -> . FOR name = exp , exp , exp DO block END
    (24) stat -> . FOR namelist IN explist DO block END
    (35) varlist -> . var
    (36) varlist -> . varlist , var
    (60) functioncall -> . prefixexp args
    (61) functioncall -> . prefixexp : name args
    (25) if -> . IF exp THEN block
    (32) var -> . name
    (33) var -> . prefixexp [ exp ]
    (34) var -> . prefixexp . name
    (56) prefixexp -> . var
    (57) prefixexp -> . functioncall
    (58) prefixexp -> . ( exp )
    (37) name -> . IDENTIFIER

    RETURN          shift and go to state 6
    BREAK           shift and go to state 7
    LOCAL           shift and go to state 9
    FUNCTION        shift and go to state 10
    DO              shift and go to state 13
    WHILE           shift and go to state 14
    REPEAT          shift and go to state 15
    FOR             shift and go to state 17
    IF              shift and go to state 20
    (               shift and go to state 21
    IDENTIFIER      shift and go to state 22

    name                           shift and go to state 11
    block                          shift and go to state 211
    chunk                          shift and go to state 2
    chunk2                         shift and go to state 3
    laststat                       shift and go to state 4
    stat                           shift and go to state 5
    varlist                        shift and go to state 8
    functioncall                   shift and go to state 12
    if                             shift and go to state 16
    var                            shift and go to state 18
    prefixexp                      shift and go to state 19

state 210

    (22) stat -> FOR name = exp , exp DO block END .

    ;               reduce using rule 22 (stat -> FOR name = exp , exp DO block END .)
    RETURN          reduce using rule 22 (stat -> FOR name = exp , exp DO block END .)
    BREAK           reduce using rule 22 (stat -> FOR name = exp , exp DO block END .)
    LOCAL           reduce using rule 22 (stat -> FOR name = exp , exp DO block END .)
    FUNCTION        reduce using rule 22 (stat -> FOR name = exp , exp DO block END .)
    DO              reduce using rule 22 (stat -> FOR name = exp , exp DO block END .)
    WHILE           reduce using rule 22 (stat -> FOR name = exp , exp DO block END .)
    REPEAT          reduce using rule 22 (stat -> FOR name = exp , exp DO block END .)
    FOR             reduce using rule 22 (stat -> FOR name = exp , exp DO block END .)
    IF              reduce using rule 22 (stat -> FOR name = exp , exp DO block END .)
    (               reduce using rule 22 (stat -> FOR name = exp , exp DO block END .)
    IDENTIFIER      reduce using rule 22 (stat -> FOR name = exp , exp DO block END .)
    $end            reduce using rule 22 (stat -> FOR name = exp , exp DO block END .)
    END             reduce using rule 22 (stat -> FOR name = exp , exp DO block END .)
    UNTIL           reduce using rule 22 (stat -> FOR name = exp , exp DO block END .)
    ELSEIF          reduce using rule 22 (stat -> FOR name = exp , exp DO block END .)
    ELSE            reduce using rule 22 (stat -> FOR name = exp , exp DO block END .)


state 211

    (23) stat -> FOR name = exp , exp , exp DO block . END

    END             shift and go to state 212


state 212

    (23) stat -> FOR name = exp , exp , exp DO block END .

    ;               reduce using rule 23 (stat -> FOR name = exp , exp , exp DO block END .)
    RETURN          reduce using rule 23 (stat -> FOR name = exp , exp , exp DO block END .)
    BREAK           reduce using rule 23 (stat -> FOR name = exp , exp , exp DO block END .)
    LOCAL           reduce using rule 23 (stat -> FOR name = exp , exp , exp DO block END .)
    FUNCTION        reduce using rule 23 (stat -> FOR name = exp , exp , exp DO block END .)
    DO              reduce using rule 23 (stat -> FOR name = exp , exp , exp DO block END .)
    WHILE           reduce using rule 23 (stat -> FOR name = exp , exp , exp DO block END .)
    REPEAT          reduce using rule 23 (stat -> FOR name = exp , exp , exp DO block END .)
    FOR             reduce using rule 23 (stat -> FOR name = exp , exp , exp DO block END .)
    IF              reduce using rule 23 (stat -> FOR name = exp , exp , exp DO block END .)
    (               reduce using rule 23 (stat -> FOR name = exp , exp , exp DO block END .)
    IDENTIFIER      reduce using rule 23 (stat -> FOR name = exp , exp , exp DO block END .)
    $end            reduce using rule 23 (stat -> FOR name = exp , exp , exp DO block END .)
    END             reduce using rule 23 (stat -> FOR name = exp , exp , exp DO block END .)
    UNTIL           reduce using rule 23 (stat -> FOR name = exp , exp , exp DO block END .)
    ELSEIF          reduce using rule 23 (stat -> FOR name = exp , exp , exp DO block END .)
    ELSE            reduce using rule 23 (stat -> FOR name = exp , exp , exp DO block END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FUNCTION in state 6 resolved as shift
WARNING: shift/reduce conflict for ( in state 6 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 6 resolved as shift
WARNING: shift/reduce conflict for ELSEIF in state 16 resolved as shift
WARNING: shift/reduce conflict for ( in state 38 resolved as shift
WARNING: shift/reduce conflict for OR in state 46 resolved as shift
WARNING: shift/reduce conflict for AND in state 47 resolved as shift
WARNING: shift/reduce conflict for LT in state 48 resolved as shift
WARNING: shift/reduce conflict for LTE in state 48 resolved as shift
WARNING: shift/reduce conflict for GT in state 48 resolved as shift
WARNING: shift/reduce conflict for GTE in state 48 resolved as shift
WARNING: shift/reduce conflict for NE in state 48 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 48 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 49 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 50 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 50 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 51 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 51 resolved as shift
WARNING: shift/reduce conflict for % in state 51 resolved as shift
WARNING: shift/reduce conflict for CIRCUMFLEX in state 55 resolved as shift
WARNING: shift/reduce conflict for DO in state 68 resolved as shift
WARNING: shift/reduce conflict for THEN in state 83 resolved as shift
WARNING: shift/reduce conflict for ) in state 84 resolved as shift
WARNING: shift/reduce conflict for CIRCUMFLEX in state 111 resolved as shift
WARNING: shift/reduce conflict for CIRCUMFLEX in state 111 resolved as shift
WARNING: shift/reduce conflict for CIRCUMFLEX in state 113 resolved as shift
WARNING: shift/reduce conflict for CIRCUMFLEX in state 113 resolved as shift
WARNING: shift/reduce conflict for CIRCUMFLEX in state 115 resolved as shift
WARNING: shift/reduce conflict for CIRCUMFLEX in state 115 resolved as shift
WARNING: shift/reduce conflict for THEN in state 132 resolved as shift
WARNING: shift/reduce conflict for ] in state 136 resolved as shift
WARNING: shift/reduce conflict for ] in state 153 resolved as shift
WARNING: shift/reduce conflict for AND in state 155 resolved as shift
WARNING: shift/reduce conflict for AND in state 155 resolved as shift
WARNING: shift/reduce conflict for LT in state 156 resolved as shift
WARNING: shift/reduce conflict for LTE in state 156 resolved as shift
WARNING: shift/reduce conflict for GT in state 156 resolved as shift
WARNING: shift/reduce conflict for GTE in state 156 resolved as shift
WARNING: shift/reduce conflict for NE in state 156 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 156 resolved as shift
WARNING: shift/reduce conflict for LT in state 156 resolved as shift
WARNING: shift/reduce conflict for LTE in state 156 resolved as shift
WARNING: shift/reduce conflict for GT in state 156 resolved as shift
WARNING: shift/reduce conflict for GTE in state 156 resolved as shift
WARNING: shift/reduce conflict for NE in state 156 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 156 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 157 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 157 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 158 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 158 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 159 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 159 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 160 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 160 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 161 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 161 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 162 resolved as shift
WARNING: shift/reduce conflict for CONCAT in state 162 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 163 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 163 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 163 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 163 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 164 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 164 resolved as shift
WARNING: shift/reduce conflict for % in state 164 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 164 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 164 resolved as shift
WARNING: shift/reduce conflict for % in state 164 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 165 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 165 resolved as shift
WARNING: shift/reduce conflict for % in state 165 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 165 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 165 resolved as shift
WARNING: shift/reduce conflict for % in state 165 resolved as shift
WARNING: shift/reduce conflict for , in state 180 resolved as shift
WARNING: shift/reduce conflict for DO in state 200 resolved as shift
WARNING: shift/reduce conflict for , in state 200 resolved as shift
WARNING: shift/reduce conflict for DO in state 207 resolved as shift
WARNING: reduce/reduce conflict in state 12 resolved using rule (stat -> functioncall)
WARNING: rejected rule (prefixexp -> functioncall) in state 12
WARNING: reduce/reduce conflict in state 30 resolved using rule (explist -> exp)
WARNING: rejected rule (op_9 -> exp) in state 30
WARNING: reduce/reduce conflict in state 95 resolved using rule (field -> exp)
WARNING: rejected rule (op_9 -> exp) in state 95
WARNING: reduce/reduce conflict in state 111 resolved using rule (op_7 -> MINUS op_8)
WARNING: rejected rule (op_7 -> op_8) in state 111
WARNING: reduce/reduce conflict in state 113 resolved using rule (op_7 -> NOT op_8)
WARNING: rejected rule (op_7 -> op_8) in state 113
WARNING: reduce/reduce conflict in state 115 resolved using rule (op_7 -> HASH op_8)
WARNING: rejected rule (op_7 -> op_8) in state 115
WARNING: reduce/reduce conflict in state 142 resolved using rule (explist -> explist , exp)
WARNING: rejected rule (op_9 -> exp) in state 142
WARNING: reduce/reduce conflict in state 155 resolved using rule (op_1 -> op_1 OR op_2)
WARNING: rejected rule (op_1 -> op_2) in state 155
WARNING: reduce/reduce conflict in state 156 resolved using rule (op_2 -> op_2 AND op_3)
WARNING: rejected rule (op_2 -> op_3) in state 156
WARNING: reduce/reduce conflict in state 157 resolved using rule (op_3 -> op_3 LT op_4)
WARNING: rejected rule (op_3 -> op_4) in state 157
WARNING: reduce/reduce conflict in state 158 resolved using rule (op_3 -> op_3 LTE op_4)
WARNING: rejected rule (op_3 -> op_4) in state 158
WARNING: reduce/reduce conflict in state 159 resolved using rule (op_3 -> op_3 GT op_4)
WARNING: rejected rule (op_3 -> op_4) in state 159
WARNING: reduce/reduce conflict in state 160 resolved using rule (op_3 -> op_3 GTE op_4)
WARNING: rejected rule (op_3 -> op_4) in state 160
WARNING: reduce/reduce conflict in state 161 resolved using rule (op_3 -> op_3 NE op_4)
WARNING: rejected rule (op_3 -> op_4) in state 161
WARNING: reduce/reduce conflict in state 162 resolved using rule (op_3 -> op_3 EQUALS op_4)
WARNING: rejected rule (op_3 -> op_4) in state 162
WARNING: reduce/reduce conflict in state 163 resolved using rule (op_4 -> op_4 CONCAT op_5)
WARNING: rejected rule (op_4 -> op_5) in state 163
WARNING: reduce/reduce conflict in state 164 resolved using rule (op_5 -> op_5 PLUS op_6)
WARNING: rejected rule (op_5 -> op_6) in state 164
WARNING: reduce/reduce conflict in state 165 resolved using rule (op_5 -> op_5 MINUS op_6)
WARNING: rejected rule (op_5 -> op_6) in state 165
WARNING: reduce/reduce conflict in state 166 resolved using rule (op_6 -> op_6 TIMES op_7)
WARNING: rejected rule (op_6 -> op_7) in state 166
WARNING: reduce/reduce conflict in state 167 resolved using rule (op_6 -> op_6 DIVIDE op_7)
WARNING: rejected rule (op_6 -> op_7) in state 167
WARNING: reduce/reduce conflict in state 168 resolved using rule (op_6 -> op_6 % op_7)
WARNING: rejected rule (op_6 -> op_7) in state 168
WARNING: reduce/reduce conflict in state 169 resolved using rule (op_8 -> op_8 CIRCUMFLEX op_9)
WARNING: rejected rule (op_8 -> op_9) in state 169
WARNING: reduce/reduce conflict in state 176 resolved using rule (stat -> REPEAT block UNTIL exp)
WARNING: rejected rule (op_9 -> exp) in state 176
WARNING: reduce/reduce conflict in state 191 resolved using rule (field -> name = exp)
WARNING: rejected rule (op_9 -> exp) in state 191
WARNING: reduce/reduce conflict in state 203 resolved using rule (field -> [ exp ] = exp)
WARNING: rejected rule (op_9 -> exp) in state 203
